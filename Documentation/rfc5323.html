<!DOCTYPE html>
<html lang="en"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>Web Distributed Authoring and Versioning (WebDAV) SEARCH</title><script type="application/javascript">
function getMeta(rfcno, container) {

  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://tools.ietf.org/draft/rfc" + rfcno + "/state.xml", true);
  xhr.onload = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var doc = xhr.responseXML;
        var info = getChildByName(doc.documentElement, "info");
  
        var cont = document.getElementById(container);
        // empty the container
        while (cont.firstChild) {
          cont.removeChild(myNode.firstChild);
        }      
  
        var c = getChildByName(info, "stdstatus");
        if (c !== null) {
          var bld = newElementWithText("b", c.textContent);
          cont.appendChild(bld);
        }
  
        c = getChildByName(info, "updatedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Updated by: "));
          appendRfcLinks(cont, c.textContent);
        }
  
        c = getChildByName(info, "obsoletedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Obsoleted by: "));
          appendRfcLinks(cont, c.textContent);
        }
        
        c = getChildByName(info, "errata");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          var link = newElementWithText("a", "errata");
          link.setAttribute("href", "http://www.rfc-editor.org/errata_search.php?rfc=" + rfcno);
          var errata = newElementWithText("i", "This document has ");
          errata.appendChild(link);
          errata.appendChild(newText("."));
          cont.appendChild(errata);
        }

        cont.style.display = "block";
      } else {
        console.error(xhr.statusText);
      }
    }
  };
  xhr.onerror = function (e) {
    console.error(xhr.status + " " + xhr.statusText);
  };
  xhr.send(null);
}

// DOM helpers
function newElement(name) {
  return document.createElement(name);
}
function newElementWithText(name, txt) {
  var e = document.createElement(name);
  e.appendChild(newText(txt));
  return e;
}
function newText(text) {
  return document.createTextNode(text);
}

function getChildByName(parent, name) {
  if (parent === null) {
    return null;
  }
  else {
    for (var c = parent.firstChild; c !== null; c = c.nextSibling) {
      if (name == c.nodeName) {
        return c;
      }
    }
    return null;
  }
}

function appendRfcLinks(parent, text) {
  var updates = text.split(",");
  for (var i = 0; i < updates.length; i++) {
    var rfc = updates[i].trim();
    if (rfc.substring(0, 3) == "rfc") {
      var link = newElement("a");
      link.setAttribute("href", "http://tools.ietf.org/html/" + rfc);
      link.appendChild(newText(rfc.substring(3)));
      parent.appendChild(link);
    } else {
      parent.appendChild(newText(rfc));
    }
    if (i != updates.length - 1) {
      parent.appendChild(newText(", "));
    }
  }
}
</script><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: cambria, georgia, serif;
  font-size: 12pt;
  margin: 2em auto;
  max-width: 1000px;
}
samp, span.tt, code, pre {
  font-family: consolas, monaco, monospace;
}
cite {
  font-style: normal;
}
aside {
  margin-left: 2em;
}
dl {
  margin-left: 2em;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: .0em;
}
dl > dd > dl {
  margin-top: 0.5em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dl.reference > dt {
  font-weight: bold;
}
dl.reference > dd {
  margin-left: 6em;
}
h1 {
  color: green;
  font-size: 150%;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
  margin-bottom: 0pt;
}
h2 {
  font-size: 130%;
  line-height: 21pt;
  page-break-after: avoid;
}
h2.np {
  page-break-before: always;
}
h3 {
  font-size: 120%;
  line-height: 15pt;
  page-break-after: avoid;
}
h4 {
  font-size: 110%;
  page-break-after: avoid;
}
h5, h6 {
  page-break-after: avoid;
}
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  font-size: 11pt;
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
}
pre.inline {
  background-color: white;
  padding: 0em;
  page-break-inside: auto;
  border: none !important;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
div.tt {
  margin-left: 2em;
} 
table.tt {
  border-collapse: collapse;
  border-color: gray;
  border-spacing: 0; 
  vertical-align: top;
 }
table.tt th {
  border-color: gray;
  padding: 3px;
}
table.tt td {
  border-color: gray;
  padding: 3px;
}
table.all {
  border-style: solid;
  border-width: 2px;
}
table.full {
  border-style: solid;
  border-width: 2px;
}
table.tt td {
  vertical-align: top;
}
table.all td {
  border-style: solid;
  border-width: 1px;
}
table.full td {
  border-style: none solid;
  border-width: 1px;
}
table.tt th {
  vertical-align: top;
}
table.all th {
  border-style: solid;
  border-width: 1px;
}
table.full th {
  border-style: solid;
  border-width: 1px 1px 2px 1px;
}
table.headers th {
  border-style: none none solid none;
  border-width: 2px;
}
table.tleft {
  margin-right: auto;
}
table.tright {
  margin-left: auto;
}
table.tcenter {
  margin-left: auto;
  margin-right: auto;
}
caption {
  caption-side: bottom;
  font-weight: bold;
  font-size: 10pt;
  margin-top: .5em;
}

table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 11pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 11pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
.filename, h1, h2, h3, h4 {
  font-family: candara, calibri, segoe, optima, arial, sans-serif;
}
ul.ind, ul.ind ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
  page-break-before: avoid;
}
ul.ind li {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
}
ul.ind li li {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
}
.avoidbreakinside {
  page-break-inside: avoid;
}
.avoidbreakafter {
  page-break-after: avoid;
}
.bcp14 {
  font-style: normal;
  text-transform: lowercase;
  font-variant: small-caps;
}
.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 10pt;
}
.filename {
  color: #333333;
  font-size: 112%;
  font-weight: bold;
  line-height: 21pt;
  text-align: center;
  margin-top: 0pt;
}
.fn {
  font-weight: bold;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.warning {
  font-size: 130%;
  background-color: yellow;
}
.self {
    color: #999999;
    margin-left: .3em;
    text-decoration: none;
    visibility: hidden;
    -webkit-user-select: none; 
    -moz-user-select: none;
    -ms-user-select: none;
}
.self:hover {
    text-decoration: none;
}
p:hover .self {
    visibility: visible;
}
.docstatus {
  border: 1px solid black;
  display: none;
  float: right;
  margin: 2em;
  padding: 1em;
}

@media screen {
  pre.text, pre.text2 {
    width: 69em;
  }
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 110%;
  }

  ul.toc a:last-child::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  pre {
    font-size: 10pt;
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}
@page {
  @top-left {
       content: "RFC 5323";
  }
  @top-right {
       content: "November 2008";
  }
  @top-center {
       content: "WebDAV SEARCH";
  }
  @bottom-left {
       content: "Reschke, et al.";
  }
  @bottom-center {
       content: "Standards Track";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}
@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyrightnotice"><link rel="Index" href="#rfc.index"><link rel="Chapter" title="1 Introduction" href="#rfc.section.1"><link rel="Chapter" title="2 The SEARCH Method" href="#rfc.section.2"><link rel="Chapter" title="3 Discovery of Supported Query Grammars" href="#rfc.section.3"><link rel="Chapter" title="4 Query Schema Discovery: QSD" href="#rfc.section.4"><link rel="Chapter" title="5 The DAV:basicsearch Grammar" href="#rfc.section.5"><link rel="Chapter" title="6 Internationalization Considerations" href="#rfc.section.6"><link rel="Chapter" title="7 Security Considerations" href="#rfc.section.7"><link rel="Chapter" title="8 Scalability" href="#rfc.section.8"><link rel="Chapter" title="9 IANA Considerations" href="#rfc.section.9"><link rel="Chapter" title="10 Contributors" href="#rfc.section.10"><link rel="Chapter" title="11 Acknowledgements" href="#rfc.section.11"><link rel="Chapter" href="#rfc.section.12" title="12 References"><link rel="Appendix" title="A Three-Valued Logic in DAV:basicsearch" href="#rfc.section.A"><link rel="Appendix" title="B Candidates for Future Protocol Extensions" href="#rfc.section.B"><link rel="Alternate" title="Authoritative ASCII Version" href="http://www.ietf.org/rfc/rfc5323.txt"><link rel="Help" title="RFC-Editor's Status Page" href="http://www.rfc-editor.org/info/rfc5323"><link rel="Help" title="Additional Information on tools.ietf.org" href="http://tools.ietf.org/html/rfc5323"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.840, 2016/11/16 05:32:10, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/"><meta name="keywords" content="HTTP, Query, Properties"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Reschke, J. F."><meta name="dcterms.creator" content="Reddy, S."><meta name="dcterms.creator" content="Davis, J."><meta name="dcterms.creator" content="Babich, A."><meta name="dcterms.identifier" content="urn:ietf:rfc:5323"><meta name="dcterms.issued" content="2008-11"><meta name="dcterms.abstract" content="This document specifies a set of methods, headers, and properties composing Web Distributed Authoring and Versioning (WebDAV) SEARCH, an application of the HTTP/1.1 protocol to efficiently search for DAV resources based upon a set of client-supplied criteria."><meta name="dcterms.isPartOf" content="urn:issn:2070-1721"><meta name="description" content="This document specifies a set of methods, headers, and properties composing Web Distributed Authoring and Versioning (WebDAV) SEARCH, an application of the HTTP/1.1 protocol to efficiently search for DAV resources based upon a set of client-supplied criteria."></head><body onload="getMeta(5323,&#34;rfc.meta&#34;);"><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">Network Working Group</td><td class="right">J. Reschke, Editor</td></tr><tr><td class="left">Request for Comments: 5323</td><td class="right">greenbytes</td></tr><tr><td class="left">Category: Standards Track</td><td class="right">S. Reddy</td></tr><tr><td class="left"></td><td class="right">Mitrix</td></tr><tr><td class="left"></td><td class="right">J. Davis</td></tr><tr><td class="left"></td><td class="right">A. Babich</td></tr><tr><td class="left"></td><td class="right">IBM</td></tr><tr><td class="left"></td><td class="right">November 2008</td></tr></tbody></table><div id="rfc.title"><h1>Web Distributed Authoring and Versioning (WebDAV) SEARCH</h1></div></header><div id="rfc.meta" class="docstatus"></div><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#8220;Internet Official Protocol Standards&#8221; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright &copy; 2008 IETF Trust and the persons identified as the document authors. All rights reserved.</p><p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (<a href="http://trustee.ietf.org/license-info">http://trustee.ietf.org/license-info</a>) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.</p></section><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><p>This document specifies a set of methods, headers, and properties composing Web Distributed Authoring and Versioning (WebDAV) SEARCH, an application of the HTTP/1.1 protocol to efficiently search for DAV resources based upon a set of client-supplied criteria.</p></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1">Introduction</a><ul><li><a href="#rfc.section.1.1">1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">DASL</a></li><li><a href="#rfc.section.1.2">1.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.2">Relationship to DAV</a></li><li><a href="#rfc.section.1.3">1.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.3">Terms</a></li><li><a href="#rfc.section.1.4">1.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.4">Notational Conventions</a></li><li><a href="#rfc.section.1.5">1.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.5">Note on Usage of 'DAV:' XML Namespace</a></li><li><a href="#rfc.section.1.6">1.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.6">An Overview of DASL at Work</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#METHOD_SEARCH">The SEARCH Method</a><ul><li><a href="#rfc.section.2.1">2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.1">Overview</a></li><li><a href="#rfc.section.2.2">2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2">The Request</a><ul><li><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.2.1">The Request-URI</a></li><li><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;&nbsp;&nbsp;<a href="#request.body">The Request Body</a></li></ul></li><li><a href="#rfc.section.2.3">2.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3">The Successful 207 (Multistatus) Response</a><ul><li><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3.1">Result Set Truncation</a></li><li><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3.2">Extending the PROPFIND Response</a></li><li><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3.3">Example: A Simple Request and Response</a></li><li><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.3.4">Example: Result Set Truncation</a></li></ul></li><li><a href="#rfc.section.2.4">2.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.4">Unsuccessful Responses</a><ul><li><a href="#rfc.section.2.4.1">2.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2.4.1">Example of an Invalid Scope</a></li></ul></li></ul></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#discovery.of.supported.query.grammars">Discovery of Supported Query Grammars</a><ul><li><a href="#rfc.section.3.1">3.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">The OPTIONS Method</a></li><li><a href="#rfc.section.3.2">3.2.</a>&nbsp;&nbsp;&nbsp;<a href="#header.dasl">The DASL Response Header</a></li><li><a href="#rfc.section.3.3">3.3.</a>&nbsp;&nbsp;&nbsp;<a href="#PROPERTY_supported-query-grammar-set">DAV:supported-query-grammar-set (Protected)</a></li><li><a href="#rfc.section.3.4">3.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4">Example: Grammar Discovery</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#QSD">Query Schema Discovery: QSD</a><ul><li><a href="#rfc.section.4.1">4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#additional.search.semantics">Additional SEARCH Semantics</a><ul><li><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1.1">Example of Query Schema Discovery</a></li></ul></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#basicsearch">The DAV:basicsearch Grammar</a><ul><li><a href="#rfc.section.5.1">5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.1">Introduction</a></li><li><a href="#rfc.section.5.2">5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.2">The DAV:basicsearch DTD</a><ul><li><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.2.1">Example Query</a></li></ul></li><li><a href="#rfc.section.5.3">5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.3">DAV:select</a></li><li><a href="#rfc.section.5.4">5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4">DAV:from</a><ul><li><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.1">Relationship to the Request-URI</a></li><li><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.4.2">Scope</a></li></ul></li><li><a href="#rfc.section.5.5">5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5">DAV:where</a><ul><li><a href="#rfc.section.5.5.1">5.5.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5.1">Use of Three-Valued Logic in Queries</a></li><li><a href="#rfc.section.5.5.2">5.5.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5.2">Handling Optional Operators</a></li><li><a href="#rfc.section.5.5.3">5.5.3.</a>&nbsp;&nbsp;&nbsp;<a href="#null-values">Treatment of NULL Values</a></li><li><a href="#rfc.section.5.5.4">5.5.4.</a>&nbsp;&nbsp;&nbsp;<a href="#non-simple-types">Treatment of Properties with Mixed/Element Content</a></li><li><a href="#rfc.section.5.5.5">5.5.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5.5">Example: Testing for Equality</a></li><li><a href="#rfc.section.5.5.6">5.5.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.5.6">Example: Relative Comparisons</a></li></ul></li><li><a href="#rfc.section.5.6">5.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.6">DAV:orderby</a><ul><li><a href="#rfc.section.5.6.1">5.6.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.6.1">Example of Sorting</a></li></ul></li><li><a href="#rfc.section.5.7">5.7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.7">Boolean Operators: DAV:and, DAV:or, and DAV:not</a></li><li><a href="#rfc.section.5.8">5.8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.8">DAV:eq</a></li><li><a href="#rfc.section.5.9">5.9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.9">DAV:lt, DAV:lte, DAV:gt, DAV:gte</a></li><li><a href="#rfc.section.5.10">5.10.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.10">DAV:literal</a></li><li><a href="#rfc.section.5.11">5.11.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.11">DAV:typed-literal (Optional)</a><ul><li><a href="#rfc.section.5.11.1">5.11.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.11.1">Example for Typed Numerical Comparison</a></li></ul></li><li><a href="#rfc.section.5.12">5.12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.12">Support for Matching xml:lang Attributes on Properties</a><ul><li><a href="#rfc.section.5.12.1">5.12.1.</a>&nbsp;&nbsp;&nbsp;<a href="#operator.language-defined">DAV:language-defined (Optional)</a></li><li><a href="#rfc.section.5.12.2">5.12.2.</a>&nbsp;&nbsp;&nbsp;<a href="#operator.language-matches">DAV:language-matches (Optional)</a></li><li><a href="#rfc.section.5.12.3">5.12.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.12.3">Example of Language-Aware Matching</a></li></ul></li><li><a href="#rfc.section.5.13">5.13.</a>&nbsp;&nbsp;&nbsp;<a href="#OPERATOR_is-collection">DAV:is-collection</a><ul><li><a href="#rfc.section.5.13.1">5.13.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.13.1">Example of DAV:is-collection</a></li></ul></li><li><a href="#rfc.section.5.14">5.14.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.14">DAV:is-defined</a></li><li><a href="#rfc.section.5.15">5.15.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.15">DAV:like</a><ul><li><a href="#rfc.section.5.15.1">5.15.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.15.1">Syntax for the Literal Pattern</a></li><li><a href="#rfc.section.5.15.2">5.15.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.15.2">Example of DAV:like</a></li></ul></li><li><a href="#rfc.section.5.16">5.16.</a>&nbsp;&nbsp;&nbsp;<a href="#contains">DAV:contains</a><ul><li><a href="#rfc.section.5.16.1">5.16.1.</a>&nbsp;&nbsp;&nbsp;<a href="#score">Result Scoring (DAV:score Element)</a></li><li><a href="#rfc.section.5.16.2">5.16.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.16.2">Ordering by Score</a></li><li><a href="#rfc.section.5.16.3">5.16.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.16.3">Examples</a></li></ul></li><li><a href="#rfc.section.5.17">5.17.</a>&nbsp;&nbsp;&nbsp;<a href="#limiting.the.result.set">Limiting the Result Set</a><ul><li><a href="#rfc.section.5.17.1">5.17.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.17.1">Relationship to Result Ordering</a></li></ul></li><li><a href="#rfc.section.5.18">5.18.</a>&nbsp;&nbsp;&nbsp;<a href="#caseless">The 'caseless' XML Attribute</a></li><li><a href="#rfc.section.5.19">5.19.</a>&nbsp;&nbsp;&nbsp;<a href="#qs-basicsearch">Query Schema for DAV:basicsearch</a><ul><li><a href="#rfc.section.5.19.1">5.19.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.1">DTD for DAV:basicsearch QSD</a></li><li><a href="#rfc.section.5.19.2">5.19.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.2">DAV:propdesc Element</a></li><li><a href="#rfc.section.5.19.3">5.19.3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.3">The DAV:datatype Property Description</a></li><li><a href="#rfc.section.5.19.4">5.19.4.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.4">The DAV:searchable Property Description</a></li><li><a href="#rfc.section.5.19.5">5.19.5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.5">The DAV:selectable Property Description</a></li><li><a href="#rfc.section.5.19.6">5.19.6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.6">The DAV:sortable Property Description</a></li><li><a href="#rfc.section.5.19.7">5.19.7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.7">The DAV:caseless Property Description</a></li><li><a href="#rfc.section.5.19.8">5.19.8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5.19.8">The DAV:operators XML Element</a></li><li><a href="#rfc.section.5.19.9">5.19.9.</a>&nbsp;&nbsp;&nbsp;<a href="#example.qsd.basicsearch">Example of Query Schema for DAV:basicsearch</a></li></ul></li></ul></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Internationalization Considerations</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7">Security Considerations</a><ul><li><a href="#rfc.section.7.1">7.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.7.1">Implications of XML External Entities</a></li></ul></li><li><a href="#rfc.section.8">8.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.8">Scalability</a></li><li><a href="#rfc.section.9">9.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9">IANA Considerations</a><ul><li><a href="#rfc.section.9.1">9.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1">HTTP Headers</a><ul><li><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.9.1.1">DASL</a></li></ul></li></ul></li><li><a href="#rfc.section.10">10.</a>&nbsp;&nbsp;&nbsp;<a href="#contributors">Contributors</a></li><li><a href="#rfc.section.11">11.</a>&nbsp;&nbsp;&nbsp;<a href="#acknowledgements">Acknowledgements</a></li><li><a href="#rfc.section.12">12.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a><ul><li><a href="#rfc.section.12.1">12.1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.1">Normative References</a></li><li><a href="#rfc.section.12.2">12.2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references.2">Informative References</a></li></ul></li><li><a href="#rfc.section.A">A.</a>&nbsp;&nbsp;&nbsp;<a href="#three-valued-logic">Three-Valued Logic in DAV:basicsearch</a></li><li><a href="#rfc.section.B">B.</a>&nbsp;&nbsp;&nbsp;<a href="#future.protocol.extensions">Candidates for Future Protocol Extensions</a><ul><li><a href="#rfc.section.B.1">B.1.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.collations">Collation Support</a></li><li><a href="#rfc.section.B.2">B.2.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.count">Count</a></li><li><a href="#rfc.section.B.3">B.3.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.diagnostics">Diagnostics for Unsupported Queries</a></li><li><a href="#rfc.section.B.4">B.4.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.language.matching">Language Matching</a></li><li><a href="#rfc.section.B.5">B.5.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.mediatype-match">Matching Media Types</a></li><li><a href="#rfc.section.B.6">B.6.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.query-by-name">Query by Name</a></li><li><a href="#rfc.section.B.7">B.7.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.result-paging">Result Paging</a></li><li><a href="#rfc.section.B.8">B.8.</a>&nbsp;&nbsp;&nbsp;<a href="#extensions.search.scope.discovery">Search Scope Discovery</a></li></ul></li><li><a href="#rfc.index">Index</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li></ul></nav><section id="n-introduction_1"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#n-introduction_1">Introduction</a></h2><section id="n-dasl_1"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a>&nbsp;<a href="#n-dasl_1">DASL</a></h3><div id="rfc.section.1.1.p.1"><p>This document defines Web Distributed Authoring and Versioning (WebDAV) SEARCH, an application of HTTP/1.1 forming a lightweight search protocol to transport queries and result sets that allows clients to make use of server-side search facilities. It is based on earlier work done in the IETF DASL Working Group (see <a href="#contributors" title="Contributors">Section&nbsp;10</a>). In this specification, the terms "WebDAV SEARCH" and "DASL" are used interchangeably.<a class="self" href="#rfc.section.1.1.p.1">&para;</a></p></div><div id="rfc.section.1.1.p.2"><p>DASL minimizes the complexity of clients so as to facilitate widespread deployment of applications capable of utilizing the DASL search mechanisms.<a class="self" href="#rfc.section.1.1.p.2">&para;</a></p></div><div id="rfc.section.1.1.p.3"><p>DASL consists of: <a class="self" href="#rfc.section.1.1.p.3">&para;</a></p><ul><li>the SEARCH method and the request/response formats defined for it (<a href="#METHOD_SEARCH" title="The SEARCH Method">Section&nbsp;2</a>),</li><li>feature discovery through the "DASL" response header and the optional DAV:supported-grammar-set property (<a href="#discovery.of.supported.query.grammars" title="Discovery of Supported Query Grammars">Section&nbsp;3</a>),</li><li>optional grammar schema discovery (<a href="#QSD" title="Query Schema Discovery: QSD">Section&nbsp;4</a>), and</li><li>one mandatory grammar: DAV:basicsearch (<a href="#basicsearch" title="The DAV:basicsearch Grammar">Section&nbsp;5</a>).</li></ul></div></section><section id="n-relationship-to-dav"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2.</a>&nbsp;<a href="#n-relationship-to-dav">Relationship to DAV</a></h3><div id="rfc.section.1.2.p.1"><p>DASL relies on the resource and property model defined by <a href="#RFC4918" id="rfc.xref.RFC4918.1"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>. DASL does not alter this model. Instead, DASL allows clients to access DAV-modeled resources through server-side search.<a class="self" href="#rfc.section.1.2.p.1">&para;</a></p></div></section><section id="n-terms"><h3 id="rfc.section.1.3"><a href="#rfc.section.1.3">1.3.</a>&nbsp;<a href="#n-terms">Terms</a></h3><div id="rfc.section.1.3.p.1"><p>This document uses the terms defined in <a href="#RFC2616" id="rfc.xref.RFC2616.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>, <a href="#RFC4918" id="rfc.xref.RFC4918.2"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="#RFC3253" id="rfc.xref.RFC3253.1"><cite title="Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)">[RFC3253]</cite></a>, and in this section.<a class="self" href="#rfc.section.1.3.p.1">&para;</a></p></div><div id="rfc.section.1.3.p.2"><p><dfn>Criteria<span id="rfc.iref.c.1"></span></dfn> <a class="self" href="#rfc.section.1.3.p.2">&para;</a></p><ul class="empty"><li>An expression against which each resource in the search scope is evaluated.</li></ul></div><div id="rfc.section.1.3.p.3"><p><dfn>Query<span id="rfc.iref.q.1"></span></dfn> <a class="self" href="#rfc.section.1.3.p.3">&para;</a></p><ul class="empty"><li>A query is a combination of a search scope, search criteria, result record definition, sort specification, and a search modifier.</li></ul></div><div id="rfc.section.1.3.p.4"><p><dfn>Query Grammar<span id="rfc.iref.q.2"></span></dfn> <a class="self" href="#rfc.section.1.3.p.4">&para;</a></p><ul class="empty"><li>A set of definitions of XML elements, attributes, and constraints on their relations and values that defines a set of queries and the intended semantics.</li></ul></div><div id="rfc.section.1.3.p.5"><p><dfn>Query Schema<span id="rfc.iref.q.3"></span></dfn> <a class="self" href="#rfc.section.1.3.p.5">&para;</a></p><ul class="empty"><li>A listing, for any given grammar and scope, of the properties and operators that may be used in a query with that grammar and scope.</li></ul></div><div id="rfc.section.1.3.p.6"><p><dfn>Result<span id="rfc.iref.r.1"></span></dfn> <a class="self" href="#rfc.section.1.3.p.6">&para;</a></p><ul class="empty"><li>A result is a result set, optionally augmented with other information describing the search as a whole.</li></ul></div><div id="rfc.section.1.3.p.7"><p><dfn>Result Record<span id="rfc.iref.r.2"></span></dfn> <a class="self" href="#rfc.section.1.3.p.7">&para;</a></p><ul class="empty"><li>A description of a resource. A result record is a set of properties, and possibly other descriptive information.</li></ul></div><div id="rfc.section.1.3.p.8"><p><dfn>Result Record Definition<span id="rfc.iref.r.3"></span></dfn> <a class="self" href="#rfc.section.1.3.p.8">&para;</a></p><ul class="empty"><li>A specification of the set of properties to be returned in the result record.</li></ul></div><div id="rfc.section.1.3.p.9"><p><dfn>Result Set<span id="rfc.iref.r.4"></span></dfn> <a class="self" href="#rfc.section.1.3.p.9">&para;</a></p><ul class="empty"><li>A set of records, one for each resource for which the search criteria evaluated to True.</li></ul></div><div id="rfc.section.1.3.p.10"><p><dfn>Scope<span id="rfc.iref.s.1"></span></dfn> <a class="self" href="#rfc.section.1.3.p.10">&para;</a></p><ul class="empty"><li>A set of resources to be searched.</li></ul></div><div id="rfc.section.1.3.p.11"><p><dfn>Search Arbiter<span id="rfc.iref.s.2"></span></dfn> <a class="self" href="#rfc.section.1.3.p.11">&para;</a></p><ul class="empty"><li>A resource that supports the SEARCH method.</li></ul></div><div id="rfc.section.1.3.p.12"><p><dfn>Search Modifier<span id="rfc.iref.s.3"></span></dfn> <a class="self" href="#rfc.section.1.3.p.12">&para;</a></p><ul class="empty"><li>An instruction that governs the execution of the query but is not part of the search scope, result record definition, the search criteria, or the sort specification. An example of a search modifier is one that controls how much time the server can spend on the query before giving a response.</li></ul></div><div id="rfc.section.1.3.p.13"><p><dfn>Sort Specification<span id="rfc.iref.s.4"></span></dfn> <a class="self" href="#rfc.section.1.3.p.13">&para;</a></p><ul class="empty"><li>A specification of an ordering on the result records in the result set.</li></ul></div></section><section id="n-notational-conventions"><h3 id="rfc.section.1.4"><a href="#rfc.section.1.4">1.4.</a>&nbsp;<a href="#n-notational-conventions">Notational Conventions</a></h3><div id="rfc.section.1.4.p.1"><p>This specification uses the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234" id="rfc.xref.RFC5234.1"><cite title="Augmented BNF for Syntax Specifications: ABNF">[RFC5234]</cite></a>, unless explicitly stated otherwise.<a class="self" href="#rfc.section.1.4.p.1">&para;</a></p></div><div id="rfc.section.1.4.p.2"><p>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <a href="#RFC2119" id="rfc.xref.RFC2119.1"><cite title="Key words for use in RFCs to Indicate Requirement Levels">[RFC2119]</cite></a>.<a class="self" href="#rfc.section.1.4.p.2">&para;</a></p></div><div id="rfc.section.1.4.p.3"><p>This document uses XML DTD fragments (<a href="#XML" id="rfc.xref.XML.1"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a>, <a href="http://www.w3.org/TR/2006/REC-xml-20060816#elemdecls">Section 3.2</a>) as a purely notational convention. WebDAV request and response bodies cannot be validated by a DTD due to the specific extensibility rules defined in <a href="https://tools.ietf.org/html/rfc4918#section-17">Section 17</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.3"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a> and due to the fact that all XML elements defined by this specification use the XML namespace name "DAV:". In particular: <a class="self" href="#rfc.section.1.4.p.3">&para;</a></p><ol><li>element names use the "DAV:" namespace,</li><li>element ordering is irrelevant unless explicitly stated,</li><li>extension elements (elements not already defined as valid child elements) may be added anywhere, except when explicitly stated otherwise,</li><li>extension attributes (attributes not already defined as valid for this element) may be added anywhere, except when explicitly stated otherwise.</li></ol></div><div id="rfc.section.1.4.p.4"><p>When an XML element type in the "DAV:" namespace is referenced in this document outside of the context of an XML fragment, the string "DAV:" will be prefixed to the element type.<a class="self" href="#rfc.section.1.4.p.4">&para;</a></p></div><div id="rfc.section.1.4.p.5"><p>Similarly, when an XML element type in the namespace "http://www.w3.org/2001/XMLSchema" is referenced in this document outside of the context of an XML fragment, the string "xs:" will be prefixed to the element type.<a class="self" href="#rfc.section.1.4.p.5">&para;</a></p></div><div id="rfc.section.1.4.p.6"><p>This document inherits, and sometimes extends, DTD productions from <a href="https://tools.ietf.org/html/rfc4918#section-14">Section 14</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.4"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>.<a class="self" href="#rfc.section.1.4.p.6">&para;</a></p></div></section><section><h3 id="rfc.section.1.5"><a href="#rfc.section.1.5">1.5.</a>&nbsp;Note on Usage of 'DAV:' XML Namespace</h3><div id="rfc.section.1.5.p.1"><p>This specification defines elements, properties, and condition names in the XML namespace "DAV:". In general, only specifications authored by IETF working groups are supposed to do this. In this case an exception was made, because WebDAV SEARCH started its life in the IETF DASL working group (&lt;<a href="http://www.webdav.org/dasl/">http://www.webdav.org/dasl/</a>&gt;, and at the time the working group closed down there was already significant deployment of this specification.<a class="self" href="#rfc.section.1.5.p.1">&para;</a></p></div></section><section id="n-an-overview-of-dasl-at-work"><h3 id="rfc.section.1.6"><a href="#rfc.section.1.6">1.6.</a>&nbsp;<a href="#n-an-overview-of-dasl-at-work">An Overview of DASL at Work</a></h3><div id="rfc.section.1.6.p.1"><p>One can express the basic usage of DASL in the following steps: <a class="self" href="#rfc.section.1.6.p.1">&para;</a></p><ul><li>The client constructs a query using the DAV:basicsearch grammar.</li><li>The client invokes the SEARCH method on a resource that will perform the search (the search arbiter) and includes a text/xml or application/xml request entity that contains the query.</li><li>The search arbiter performs the query.</li><li>The search arbiter sends the results of the query back to the client in the response. The server <em class="bcp14">MUST</em> send an entity that matches the WebDAV multistatus format (<a href="#RFC4918" id="rfc.xref.RFC4918.5"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-13">Section 13</a>).</li></ul></div></section></section><section id="METHOD_SEARCH"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#METHOD_SEARCH">The SEARCH Method</a></h2><section id="n-overview"><h3 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a>&nbsp;<a href="#n-overview">Overview</a></h3><div id="rfc.section.2.1.p.1"><p>The client invokes the SEARCH method to initiate a server-side search. The body of the request defines the query. The server <em class="bcp14">MUST</em> emit an entity matching the WebDAV multistatus format (<a href="#RFC4918" id="rfc.xref.RFC4918.6"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-13">Section 13</a>).<a class="self" href="#rfc.section.2.1.p.1">&para;</a></p></div><div id="rfc.section.2.1.p.2"><p>The SEARCH method plays the role of transport mechanism for the query and the result set. It does not define the semantics of the query. The type of the query defines the semantics.<a class="self" href="#rfc.section.2.1.p.2">&para;</a></p></div><div id="rfc.section.2.1.p.3"><p>SEARCH is a safe method; it does not have any significance other than executing a query and returning a query result (see <a href="#RFC2616" id="rfc.xref.RFC2616.2"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>, <a href="https://tools.ietf.org/html/rfc2616#section-9.1.1">Section 9.1.1</a>).<a class="self" href="#rfc.section.2.1.p.3">&para;</a></p></div></section><section id="n-the-request"><h3 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a>&nbsp;<a href="#n-the-request">The Request</a></h3><div id="rfc.section.2.2.p.1"><p>The client invokes the SEARCH method on the resource named by the Request-URI.<a class="self" href="#rfc.section.2.2.p.1">&para;</a></p></div><section id="n-the-request-uri"><h4 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a>&nbsp;<a href="#n-the-request-uri">The Request-URI</a></h4><div id="rfc.section.2.2.1.p.1"><p>The Request-URI identifies the search arbiter. Any HTTP resource may function as search arbiter. It is not a new type of resource (in the sense of DAV:resourcetype as defined in <a href="#RFC4918" id="rfc.xref.RFC4918.7"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-15.9">Section 15.9</a>), nor does it have to be a WebDAV-compliant resource.<a class="self" href="#rfc.section.2.2.1.p.1">&para;</a></p></div><div id="rfc.section.2.2.1.p.2"><p>The SEARCH method defines no relationship between the arbiter and the scope of the search; rather, the particular query grammar used in the query defines the relationship. For example, a query grammar may force the Request-URI to correspond exactly to the search scope.<a class="self" href="#rfc.section.2.2.1.p.2">&para;</a></p></div></section><section id="request.body"><h4 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a>&nbsp;<a href="#request.body">The Request Body</a></h4><div id="rfc.section.2.2.2.p.1"><p>The server <em class="bcp14">MUST</em> process a text/xml or application/xml request body, and <em class="bcp14">MAY</em> process request bodies in other formats. See <a href="#RFC3023" id="rfc.xref.RFC3023.1"><cite title="XML Media Types">[RFC3023]</cite></a> for guidance on packaging XML in requests.<a class="self" href="#rfc.section.2.2.2.p.1">&para;</a></p></div><div id="rfc.section.2.2.2.p.2"><p><b>Marshalling:</b> <a class="self" href="#rfc.section.2.2.2.p.2">&para;</a></p><ul class="empty"><li>If a request body with content type text/xml or application/xml is included, it <em class="bcp14">MUST</em> be either a DAV:searchrequest or a DAV:query-schema-discovery XML element. Its single child element identifies the query grammar.</li><li>For DAV:searchrequest, the definition of search criteria, the result record, and any other details needed to perform the search depend on the individual search grammar.</li><li>For DAV:query-schema-discovery, the semantics is defined in <a href="#QSD" title="Query Schema Discovery: QSD">Section&nbsp;4</a>.</li></ul></div><div id="rfc.section.2.2.2.p.3"><p><b>Preconditions:</b> <a class="self" href="#rfc.section.2.2.2.p.3">&para;</a></p><ul class="empty"><li><span id="rfc.iref.d.1"></span> <span id="rfc.iref.c.2"></span> (DAV:search-grammar-discovery-supported): when an XML request body is present and has a DAV:query-schema-discovery document element, the server <em class="bcp14">MUST</em> support the query schema discovery mechanism described in <a href="#QSD" title="Query Schema Discovery: QSD">Section&nbsp;4</a>.</li><li><span id="rfc.iref.d.2"></span> <span id="rfc.iref.c.3"></span> (DAV:search-grammar-supported): when an XML request body is present, the search grammar identified by the document element's child element must be a supported search grammar.</li><li><span id="rfc.iref.d.3"></span> <span id="rfc.iref.c.4"></span> (DAV:search-multiple-scope-supported): if the SEARCH request specified multiple scopes, the server <em class="bcp14">MUST</em> support this optional feature.</li><li><span id="rfc.iref.d.4"></span> <span id="rfc.iref.c.5"></span> (DAV:search-scope-valid): the supplied search scope must be valid. There can be various reasons for a search scope to be invalid, including unsupported URI schemes and communication problems. Servers <em class="bcp14">MAY</em> add <a href="#RFC4918" id="rfc.xref.RFC4918.8"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a> compliant DAV:response elements as content to the condition element indicating the precise reason for the failure.</li></ul></div></section></section><section id="n-the-successful-207--multistatus--response"><h3 id="rfc.section.2.3"><a href="#rfc.section.2.3">2.3.</a>&nbsp;<a href="#n-the-successful-207--multistatus--response">The Successful 207 (Multistatus) Response</a></h3><div id="rfc.section.2.3.p.1"><p>If the server returns 207 (Multistatus), then the search proceeded successfully, and the response <em class="bcp14">MUST</em> use the WebDAV multistatus format (<a href="#RFC4918" id="rfc.xref.RFC4918.9"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-13">Section 13</a>). The results of this method <em class="bcp14">SHOULD NOT</em> be cached.<a class="self" href="#rfc.section.2.3.p.1">&para;</a></p></div><div id="rfc.section.2.3.p.2"><p>There <em class="bcp14">MUST</em> be one DAV:response for each resource that matched the search criteria. For each such response, the DAV:href element contains the URI of the resource, and the response <em class="bcp14">MUST</em> include a DAV:propstat element.<a class="self" href="#rfc.section.2.3.p.2">&para;</a></p></div><aside><div id="rfc.section.2.3.p.3"><p><b>Note:</b> the WebDAV multistatus format requires at least one DAV:response child element. This specification relaxes that restriction so that empty results can be represented.<a class="self" href="#rfc.section.2.3.p.3">&para;</a></p></div></aside><div id="rfc.section.2.3.p.4"><p>Note that for each matching resource found, there may be multiple URIs within the search scope mapped to it. In this case, a server <em class="bcp14">SHOULD</em> report only one of these URIs. Clients can use the live property DAV:resource-id, defined in Section 3.1 of <a href="#WEBDAV-BIND" id="rfc.xref.WEBDAV-BIND.1"><cite title="Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)">[WEBDAV-BIND]</cite></a> to identify possible duplicates.<a class="self" href="#rfc.section.2.3.p.4">&para;</a></p></div><div id="rfc.iref.r.5"></div><section id="n-result-set-truncation"><h4 id="rfc.section.2.3.1"><a href="#rfc.section.2.3.1">2.3.1.</a>&nbsp;<a href="#n-result-set-truncation">Result Set Truncation</a></h4><div id="rfc.section.2.3.1.p.1"><p>A server <em class="bcp14">MAY</em> limit the number of resources in a reply, for example, to limit the amount of resources expended in processing a query. If it does so, the reply <em class="bcp14">MUST</em> use status code 207, return a DAV:multistatus response body, and indicate a status of 507 (Insufficient Storage) for the search arbiter URI. It <em class="bcp14">SHOULD</em> include the partial results.<a class="self" href="#rfc.section.2.3.1.p.1">&para;</a></p></div><div id="rfc.section.2.3.1.p.2"><p>When a result set is truncated, there may be many more resources that satisfy the search criteria but that were not examined.<a class="self" href="#rfc.section.2.3.1.p.2">&para;</a></p></div><div id="rfc.section.2.3.1.p.3"><p>If partial results are included and the client requested an ordered result set in the original request, then any partial results that are returned <em class="bcp14">MUST</em> be ordered as the client directed.<a class="self" href="#rfc.section.2.3.1.p.3">&para;</a></p></div><div id="rfc.section.2.3.1.p.4"><p>Note that the partial results returned <em class="bcp14">MAY</em> be any subset of the result set that would have satisfied the original query.<a class="self" href="#rfc.section.2.3.1.p.4">&para;</a></p></div></section><section id="n-extending-the-propfind-response"><h4 id="rfc.section.2.3.2"><a href="#rfc.section.2.3.2">2.3.2.</a>&nbsp;<a href="#n-extending-the-propfind-response">Extending the PROPFIND Response</a></h4><div id="rfc.section.2.3.2.p.1"><p>A response <em class="bcp14">MAY</em> include more information than PROPFIND defines, so long as the extra information does not invalidate the PROPFIND response. Query grammars <em class="bcp14">SHOULD</em> define how the response matches the PROPFIND response.<a class="self" href="#rfc.section.2.3.2.p.1">&para;</a></p></div></section><section id="n-example--a-simple-request-and-response"><h4 id="rfc.section.2.3.3"><a href="#rfc.section.2.3.3">2.3.3.</a>&nbsp;<a href="#n-example--a-simple-request-and-response">Example: A Simple Request and Response</a></h4><div id="rfc.section.2.3.3.p.1"><p>This example demonstrates the request and response framework. The following XML document shows a simple (hypothetical) natural language query. The name of the query element is natural-language-query in the XML namespace "http://example.com/foo". The actual query is "Find the locations of good Thai restaurants in Los Angeles". For this hypothetical query, the arbiter returns two properties for each selected resource.<a class="self" href="#rfc.section.2.3.3.p.1">&para;</a></p></div><div id="rfc.figure.u.1"><p>&gt;&gt; Request:</p><pre class="text2">SEARCH / HTTP/1.1
Host: example.org
Content-Type: application/xml; charset="utf-8" 
Content-Length: 252

<code class="prettyprint" id="eb1">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;D:searchrequest xmlns:D="DAV:" xmlns:F="http://example.com/foo"&gt;
  &lt;F:natural-language-query&gt;
    Find the locations of good Thai restaurants in Los Angeles
  &lt;/F:natural-language-query&gt;
&lt;/D:searchrequest&gt;
</code></pre></div><div id="rfc.figure.u.2"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: 429

<code class="prettyprint" id="eb2">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;D:multistatus xmlns:D="DAV:"
   xmlns:R="http://example.org/propschema"&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;http://siamiam.example/&lt;/D:href&gt;
    &lt;D:propstat&gt;
      &lt;D:prop&gt;
        &lt;R:location&gt;259 W. Hollywood&lt;/R:location&gt;
        &lt;R:rating&gt;&lt;R:stars&gt;4&lt;/R:stars&gt;&lt;/R:rating&gt;
      &lt;/D:prop&gt;
      &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;
    &lt;/D:propstat&gt;
  &lt;/D:response&gt;
&lt;/D:multistatus&gt;
</code></pre></div></section><section id="n-example--result-set-truncation"><h4 id="rfc.section.2.3.4"><a href="#rfc.section.2.3.4">2.3.4.</a>&nbsp;<a href="#n-example--result-set-truncation">Example: Result Set Truncation</a></h4><div id="rfc.section.2.3.4.p.1"><p>In the example below, the server returns just two results, and then indicates that the result is truncated by adding a DAV:response element for the search arbiter resource with 507 (Insufficient Storage) status.<a class="self" href="#rfc.section.2.3.4.p.1">&para;</a></p></div><div id="rfc.figure.u.3"><p>&gt;&gt; Request:</p><pre class="text2">SEARCH / HTTP/1.1
Host: example.net
Content-Type: text/xml; charset="utf-8"
Content-Length: xxx

 ... the query goes here ...
</pre></div><div id="rfc.figure.u.4"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 207 Multistatus
Content-Type: text/xml; charset="utf-8"
Content-Length: 640

<code class="prettyprint" id="eb3">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;D:multistatus xmlns:D="DAV:"&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;http://www.example.net/sounds/unbrokenchain.au&lt;/D:href&gt;
    &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;
  &lt;/D:response&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;http://tech.mit.example/arch96/photos/Lesh1.jpg&lt;/D:href&gt;
    &lt;D:status&gt;HTTP/1.1 200 OK&lt;/D:status&gt;
  &lt;/D:response&gt;
  &lt;D:response&gt;
    &lt;D:href&gt;http://example.net&lt;/D:href&gt;
    &lt;D:status&gt;HTTP/1.1 507 Insufficient Storage&lt;/D:status&gt;
    &lt;D:responsedescription xml:lang="en"&gt;
       Only first two matching records were returned
    &lt;/D:responsedescription&gt;
  &lt;/D:response&gt;
&lt;/D:multistatus&gt;
</code></pre></div></section></section><section id="n-unsuccessful-responses"><h3 id="rfc.section.2.4"><a href="#rfc.section.2.4">2.4.</a>&nbsp;<a href="#n-unsuccessful-responses">Unsuccessful Responses</a></h3><div id="rfc.section.2.4.p.1"><p>If a SEARCH request could not be executed or the attempt to execute it resulted in an error, the server <em class="bcp14">MUST</em> indicate the failure with an appropriate status code and <em class="bcp14">SHOULD</em> add a response body as defined in <a href="https://tools.ietf.org/html/rfc3253#section-1.6">Section 1.6</a> of <a href="#RFC3253" id="rfc.xref.RFC3253.2"><cite title="Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)">[RFC3253]</cite></a>. Unless otherwise stated, condition elements are empty; however, specific condition elements <em class="bcp14">MAY</em> include additional child elements that describe the error condition in more detail.<a class="self" href="#rfc.section.2.4.p.1">&para;</a></p></div><section id="n-example-of-an-invalid-scope"><h4 id="rfc.section.2.4.1"><a href="#rfc.section.2.4.1">2.4.1.</a>&nbsp;<a href="#n-example-of-an-invalid-scope">Example of an Invalid Scope</a></h4><div id="rfc.section.2.4.1.p.1"><p>In the example below, a request failed because the scope identifies a HTTP resource that was not found.<a class="self" href="#rfc.section.2.4.1.p.1">&para;</a></p></div><div id="rfc.figure.u.5"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 409 Conflict
Content-Type: text/xml; charset="utf-8"   
Content-Length: 275

<code class="prettyprint" id="eb4">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;d:error xmlns:d="DAV:"&gt;
  &lt;d:search-scope-valid&gt;
    &lt;d:response&gt;
      &lt;d:href&gt;http://www.example.com/X&lt;/d:href&gt;
      &lt;d:status&gt;HTTP/1.1 404 Object Not Found&lt;/d:status&gt;
    &lt;/d:response&gt;
  &lt;/d:search-scope-valid&gt;
&lt;/d:error&gt;
</code></pre></div></section></section></section><section id="discovery.of.supported.query.grammars"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#discovery.of.supported.query.grammars">Discovery of Supported Query Grammars</a></h2><div id="rfc.section.3.p.1"><p>Servers <em class="bcp14">MUST</em> support discovery of the query grammars supported by a search arbiter resource.<a class="self" href="#rfc.section.3.p.1">&para;</a></p></div><div id="rfc.section.3.p.2"><p>Clients can determine which query grammars are supported by an arbiter by invoking OPTIONS on the search arbiter. If the resource supports SEARCH, then the DASL response header will appear in the response. The DASL response header lists the supported grammars.<a class="self" href="#rfc.section.3.p.2">&para;</a></p></div><div id="rfc.section.3.p.3"><p>Servers supporting the WebDAV extensions <a href="#RFC3253" id="rfc.xref.RFC3253.3"><cite title="Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)">[RFC3253]</cite></a> and/or <a href="#RFC3744" id="rfc.xref.RFC3744.1"><cite title="Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol">[RFC3744]</cite></a> <em class="bcp14">MUST</em> also: <a class="self" href="#rfc.section.3.p.3">&para;</a></p><ul><li>report SEARCH in the live property DAV:supported-method-set for all search arbiter resources, and</li><li>support the live property DAV:supported-query-grammar-set as defined in <a href="#PROPERTY_supported-query-grammar-set" title="DAV:supported-query-grammar-set (Protected)">Section&nbsp;3.3</a>.</li></ul></div><section id="n-the-options-method"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1.</a>&nbsp;<a href="#n-the-options-method">The OPTIONS Method</a></h3><div id="rfc.section.3.1.p.1"><p>The OPTIONS method allows the client to discover if a resource supports the SEARCH method and to determine the list of search grammars supported for that resource.<a class="self" href="#rfc.section.3.1.p.1">&para;</a></p></div><div id="rfc.section.3.1.p.2"><p>The client issues the OPTIONS method against a resource named by the Request-URI. This is a normal invocation of OPTIONS as defined in <a href="https://tools.ietf.org/html/rfc2616#section-9.2">Section 9.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.3"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>.<a class="self" href="#rfc.section.3.1.p.2">&para;</a></p></div><div id="rfc.section.3.1.p.3"><p>If a resource supports the SEARCH method, then the server <em class="bcp14">MUST</em> list SEARCH in the Allow header defined in <a href="https://tools.ietf.org/html/rfc2616#section-14.7">Section 14.7</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.4"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>.<a class="self" href="#rfc.section.3.1.p.3">&para;</a></p></div><div id="rfc.section.3.1.p.4"><p>DASL servers <em class="bcp14">MUST</em> include the DASL header in the OPTIONS response. This header identifies the search grammars supported by that resource.<a class="self" href="#rfc.section.3.1.p.4">&para;</a></p></div></section><section id="header.dasl"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2.</a>&nbsp;<a href="#header.dasl">The DASL Response Header</a></h3><div id="rfc.figure.u.6"><pre class="inline">DASLHeader = "DASL" ":" 1#Coded-URL
Coded-URL  = &lt;defined in <a href="https://tools.ietf.org/html/rfc4918#section-10.1">Section 10.1</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.10"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>&gt;
</pre><p>(This grammar uses the augmented BNF format defined in <a href="https://tools.ietf.org/html/rfc2616#section-2.1">Section 2.1</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.5"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>.)</p></div><div id="rfc.section.3.2.p.1"><p>The DASL response header indicates server support for query grammars in the OPTIONS method. The value is a list of URIs that indicate the types of supported grammars. Note that although the URIs can be used to identify each supported search grammar, there is not necessarily a direct relationship between the URI and the XML element name that can be used in XML based SEARCH requests (the element name itself is identified by its namespace name (a URI reference) and the element's local name).<a class="self" href="#rfc.section.3.2.p.1">&para;</a></p></div><aside><div id="rfc.section.3.2.p.2"><p><b>Note:</b> this header field value is defined as a comma-separated list (<a href="#RFC2616" id="rfc.xref.RFC2616.6"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>, <a href="https://tools.ietf.org/html/rfc2616#section-4.2">Section 4.2</a>); thus, grammar URIs can appear in multiple header instances, separated by commas, or both.<a class="self" href="#rfc.section.3.2.p.2">&para;</a></p></div></aside><div id="rfc.figure.u.7"><p>For example:</p><pre class="text">DASL: &lt;http://foobar.example/syntax1&gt;,
      &lt;http://akuma.example/syntax2&gt;, &lt;DAV:basicsearch&gt;
DASL: &lt;http://example.com/foo/natural-language-query&gt;
</pre></div></section><section id="PROPERTY_supported-query-grammar-set"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3.</a>&nbsp;<a href="#PROPERTY_supported-query-grammar-set">DAV:supported-query-grammar-set (Protected)</a></h3><div id="rfc.section.3.3.p.1"><p>This WebDAV property is required for any server supporting either <a href="#RFC3253" id="rfc.xref.RFC3253.4"><cite title="Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)">[RFC3253]</cite></a> and/or <a href="#RFC3744" id="rfc.xref.RFC3744.2"><cite title="Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol">[RFC3744]</cite></a> and identifies the XML-based query grammars that are supported by the search arbiter resource.<a class="self" href="#rfc.section.3.3.p.1">&para;</a></p></div><div id="rfc.figure.u.8"><pre class="inline prettyprint">&lt;!ELEMENT supported-query-grammar-set (supported-query-grammar*)&gt;
&lt;!ELEMENT supported-query-grammar (grammar)&gt;
&lt;!ELEMENT grammar ANY&gt;
&lt;!-- ANY value: a query grammar element type --&gt;
</pre></div></section><section id="n-example--grammar-discovery"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4.</a>&nbsp;<a href="#n-example--grammar-discovery">Example: Grammar Discovery</a></h3><div id="rfc.section.3.4.p.1"><p>This example shows that the server supports search on the /somefolder resource with the query grammars: DAV:basicsearch, http://foobar.example/syntax1 and http://akuma.example/syntax2. Note that servers supporting WebDAV SEARCH <em class="bcp14">MUST</em> support DAV:basicsearch.<a class="self" href="#rfc.section.3.4.p.1">&para;</a></p></div><div id="rfc.figure.u.9"><p>&gt;&gt; Request:</p><pre class="text2">OPTIONS /somefolder HTTP/1.1
Host: example.org
</pre></div><div id="rfc.figure.u.10"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 200 OK
Allow: OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, COPY, MOVE
Allow: MKCOL, PROPFIND, PROPPATCH, LOCK, UNLOCK, SEARCH
DASL: &lt;DAV:basicsearch&gt;
DASL: &lt;http://foobar.example/syntax1&gt;, &lt;http://akuma.example/syntax2&gt;
</pre></div><div id="rfc.section.3.4.p.2"><p>This example shows the equivalent taking advantage of a server's support for DAV:supported-method-set and DAV:supported-query-grammar-set.<a class="self" href="#rfc.section.3.4.p.2">&para;</a></p></div><div id="rfc.figure.u.11"><p>&gt;&gt; Request:</p><pre class="text2">PROPFIND /somefolder HTTP/1.1
Host: example.org
Depth: 0
Content-Type: text/xml; charset="utf-8"
Content-Length: 165

<code class="prettyprint" id="eb5">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;propfind xmlns="DAV:"&gt;
  &lt;prop&gt;
    &lt;supported-query-grammar-set/&gt;
    &lt;supported-method-set/&gt;
  &lt;/prop&gt;
&lt;/propfind&gt;
</code></pre></div><div id="rfc.figure.u.12"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 207 Multi-Status
Content-Type: text/xml; charset="utf-8"
Content-Length: 1349

<code class="prettyprint" id="eb6">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;multistatus xmlns="DAV:"&gt;
 &lt;response&gt;
  &lt;href&gt;http://example.org/somefolder&lt;/href&gt;
  &lt;propstat&gt;
   &lt;prop&gt;
    &lt;supported-query-grammar-set&gt;
     &lt;supported-query-grammar&gt;
      &lt;grammar&gt;&lt;basicsearch/&gt;&lt;/grammar&gt;
     &lt;/supported-query-grammar&gt;
     &lt;supported-query-grammar&gt;
      &lt;grammar&gt;&lt;syntax1 xmlns="http://foobar.example/"/&gt;&lt;/grammar&gt;
     &lt;/supported-query-grammar&gt;
     &lt;supported-query-grammar&gt;
      &lt;grammar&gt;&lt;syntax2 xmlns="http://akuma.example/"/&gt;&lt;/grammar&gt;
     &lt;/supported-query-grammar&gt;
    &lt;/supported-query-grammar-set&gt;
    &lt;supported-method-set&gt;
     &lt;supported-method name="COPY" /&gt;
     &lt;supported-method name="DELETE" /&gt;
     &lt;supported-method name="GET" /&gt;
     &lt;supported-method name="HEAD" /&gt;
     &lt;supported-method name="LOCK" /&gt;
     &lt;supported-method name="MKCOL" /&gt;
     &lt;supported-method name="MOVE" /&gt;
     &lt;supported-method name="OPTIONS" /&gt;
     &lt;supported-method name="POST" /&gt;
     &lt;supported-method name="PROPFIND" /&gt;
     &lt;supported-method name="PROPPATCH" /&gt;
     &lt;supported-method name="PUT" /&gt;
     &lt;supported-method name="SEARCH" /&gt;
     &lt;supported-method name="TRACE" /&gt;
     &lt;supported-method name="UNLOCK" /&gt;
    &lt;/supported-method-set&gt;
   &lt;/prop&gt;
   &lt;status&gt;HTTP/1.1 200 OK&lt;/status&gt;
  &lt;/propstat&gt;
 &lt;/response&gt;
&lt;/multistatus&gt;
</code></pre></div><div id="rfc.section.3.4.p.3"><p>Note that the query grammar element names marshalled as part of the DAV:supported-query-grammar-set can be directly used as element names in an XML-based query.<a class="self" href="#rfc.section.3.4.p.3">&para;</a></p></div></section></section><section id="QSD"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#QSD">Query Schema Discovery: QSD</a></h2><div id="rfc.section.4.p.1"><p>Servers <em class="bcp14">MAY</em> support the discovery of the schema for a query grammar.<a class="self" href="#rfc.section.4.p.1">&para;</a></p></div><div id="rfc.section.4.p.2"><p>The DASL response header and the DAV:supported-query-grammar-set property provide means for clients to discover the set of query grammars supported by a resource. This alone is not sufficient information for a client to generate a query. For example, the DAV:basicsearch grammar defines a set of queries consisting of a set of operators applied to a set of properties and values, but the grammar itself does not specify which properties may be used in the query. QSD for the DAV:basicsearch grammar allows a client to discover the set of properties that are searchable, selectable, and sortable. Moreover, although the DAV:basicsearch grammar defines a minimal set of operators, it is possible that a resource might support additional operators in a query. For example, a resource might support an optional operator that can be used to express content-based queries in a proprietary syntax. QSD allows a client to discover these operators and their syntax. The set of discoverable quantities will differ from grammar to grammar, but each grammar can define a means for a client to discover what can be discovered.<a class="self" href="#rfc.section.4.p.2">&para;</a></p></div><div id="rfc.section.4.p.3"><p>In general, the schema for a given query grammar depends on both the resource (the arbiter) and the scope. A given resource might have access to one set of properties for one potential scope, and another set for a different scope. For example, consider a server able to search two distinct collections: one holding cooking recipes, the other design documents for nuclear weapons. While both collections might support properties such as author, title, and date, the first might also define properties such as calories and preparation time, while the second defined properties such as yield and applicable patents. Two distinct arbiters indexing the same collection might also have access to different properties. For example, the recipe collection mentioned above might also be indexed by a value-added server that also stored the names of chefs who had tested the recipe. Note also that the available query schema might also depend on other factors, such as the identity of the principal conducting the search, but these factors are not exposed in this protocol.<a class="self" href="#rfc.section.4.p.3">&para;</a></p></div><section id="additional.search.semantics"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1.</a>&nbsp;<a href="#additional.search.semantics">Additional SEARCH Semantics</a></h3><div id="rfc.section.4.1.p.1"><p>Each query grammar supported by DASL defines its own syntax for expressing the possible query schema. A client retrieves the schema for a given query grammar on an arbiter resource with a given scope by invoking the SEARCH method on that arbiter with that grammar and scope and with a root element of DAV:query-schema-discovery rather than DAV:searchrequest.<a class="self" href="#rfc.section.4.1.p.1">&para;</a></p></div><div id="rfc.section.4.1.p.2"><p><b>Marshalling:</b> <a class="self" href="#rfc.section.4.1.p.2">&para;</a></p><ul class="empty"><li>The request body <em class="bcp14">MUST</em> be a DAV:query-schema-discovery element. <span id="rfc.figure.u.13"><pre class="inline prettyprint">&lt;!ELEMENT query-schema-discovery ANY&gt;
&lt;!-- ANY value: XML element specifying the query grammar
                and the scope --&gt;
</pre></span> </li><li>The response body takes the form of a DAV:multistatus element (<a href="#RFC4918" id="rfc.xref.RFC4918.11"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-13">Section 13</a>), where DAV:response is extended to hold the returned query grammar inside a DAV:query-schema container element. <span id="rfc.figure.u.14"><pre class="inline prettyprint">&lt;!ELEMENT response (href, status, query-schema?,
  responsedescription?) &gt;
&lt;!ELEMENT query-schema ANY&gt;
</pre></span> </li></ul></div><div id="rfc.section.4.1.p.3"><p>The content of this container is an XML element whose name and syntax depend upon the grammar, and whose value may (and likely will) vary depending upon the grammar, arbiter, and scope.<a class="self" href="#rfc.section.4.1.p.3">&para;</a></p></div><section id="n-example-of-query-schema-discovery"><h4 id="rfc.section.4.1.1"><a href="#rfc.section.4.1.1">4.1.1.</a>&nbsp;<a href="#n-example-of-query-schema-discovery">Example of Query Schema Discovery</a></h4><div id="rfc.section.4.1.1.p.1"><p>In this example, the arbiter is recipes.example, the grammar is DAV:basicsearch, the scope is also recipes.example.<a class="self" href="#rfc.section.4.1.1.p.1">&para;</a></p></div><div id="rfc.figure.u.15"><p>&gt;&gt; Request:</p><pre class="text2">SEARCH / HTTP/1.1
Host: recipes.example
Content-Type: application/xml; charset="utf-8" 
Content-Length: 258

<code class="prettyprint" id="eb7">&lt;?xml version="1.0"?&gt;
&lt;query-schema-discovery xmlns="DAV:"&gt;
  &lt;basicsearch&gt;
    &lt;from&gt;
      &lt;scope&gt;
        &lt;href&gt;http://recipes.example&lt;/href&gt;
        &lt;depth&gt;infinity&lt;/depth&gt;
      &lt;/scope&gt;
    &lt;/from&gt;
  &lt;/basicsearch&gt;
&lt;/query-schema-discovery&gt;
</code></pre></div><div id="rfc.figure.u.16"><p>&gt;&gt; Response:</p><pre class="text">HTTP/1.1 207 Multistatus
Content-Type: application/xml; charset="utf-8" 
Content-Length: xxx

<code class="prettyprint">&lt;?xml version="1.0"?&gt;
&lt;multistatus xmlns="DAV:"&gt;
  &lt;response&gt;  
    &lt;href&gt;http://recipes.example&lt;/href&gt;
    &lt;status&gt;HTTP/1.1 200 OK&lt;/status&gt;
    &lt;query-schema&gt;
      &lt;basicsearchschema&gt;
        &lt;!-- (See <a href="#qs-basicsearch" title="Query Schema for DAV:basicsearch">Section&nbsp;5.19</a> for
        the actual contents) --&gt;
      &lt;/basicsearchschema&gt;
    &lt;/query-schema&gt;
  &lt;/response&gt;
&lt;/multistatus&gt;
</code></pre></div><div id="rfc.section.4.1.1.p.2"><p>The query schema for DAV:basicsearch is defined in <a href="#qs-basicsearch" title="Query Schema for DAV:basicsearch">Section&nbsp;5.19</a>.<a class="self" href="#rfc.section.4.1.1.p.2">&para;</a></p></div></section></section></section><section id="basicsearch"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#basicsearch">The DAV:basicsearch Grammar</a></h2><section id="n-introduction_2"><h3 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a>&nbsp;<a href="#n-introduction_2">Introduction</a></h3><div id="rfc.section.5.1.p.1"><p>DAV:basicsearch uses an extensible XML syntax that allows clients to express search requests that are generally useful for WebDAV scenarios. DASL-extended servers <em class="bcp14">MUST</em> accept this grammar, and <em class="bcp14">MAY</em> accept other grammars.<a class="self" href="#rfc.section.5.1.p.1">&para;</a></p></div><div id="rfc.section.5.1.p.2" class="avoidbreakafter"><p>DAV:basicsearch has several components:<a class="self" href="#rfc.section.5.1.p.2">&para;</a></p></div><div id="rfc.section.5.1.p.3"><ul><li>DAV:select provides the result record definition.</li><li>DAV:from defines the scope.</li><li>DAV:where defines the criteria.</li><li>DAV:orderby defines the sort order of the result set.</li><li>DAV:limit provides constraints on the query as a whole.</li></ul></div></section><section id="n-the-dav-basicsearch-dtd"><h3 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a>&nbsp;<a href="#n-the-dav-basicsearch-dtd">The DAV:basicsearch DTD</a></h3><div id="rfc.figure.u.17"><p>&lt;!-- "basicsearch" element --&gt;</p><pre class="inline prettyprint">&lt;!ELEMENT <a href="#basicsearch" class="smpl">basicsearch</a>   (<a href="#select" class="smpl">select</a>, <a href="#from" class="smpl">from</a>, <a href="#where" class="smpl">where</a>?, <a href="#orderby" class="smpl">orderby</a>?, <a href="#limit" class="smpl">limit</a>?) &gt;
</pre></div><div id="rfc.figure.u.18"><p id="select">&lt;!-- "select" element --&gt;</p><pre class="inline prettyprint">&lt;!ELEMENT <a href="#select" class="smpl">select</a>        (allprop | prop) &gt;
</pre></div><div id="rfc.figure.u.19"><p id="from">&lt;!-- "from" element --&gt;</p><pre class="inline prettyprint">&lt;!ELEMENT <a href="#from" class="smpl">from</a>          (scope+) &gt;
&lt;!ELEMENT scope         (href, depth, include-versions?) &gt;
&lt;!ELEMENT include-versions EMPTY &gt;
</pre></div><div id="rfc.figure.u.20"><p id="where">&lt;!-- "where" element --&gt;</p><pre class="inline prettyprint">&lt;!ENTITY % comp_ops     "eq | lt | gt| lte | gte"&gt;
&lt;!ENTITY % log_ops      "and | or | not"&gt;
&lt;!ENTITY % special_ops  "is-collection | is-defined | 
                         language-defined | language-matches"&gt;
&lt;!ENTITY % string_ops   "like"&gt;
&lt;!ENTITY % content_ops  "contains"&gt;

&lt;!ENTITY % all_ops      "%comp_ops; | %log_ops; | %special_ops; |
                         %string_ops; | %content_ops;"&gt;

&lt;!ELEMENT <a href="#where" class="smpl">where</a>         ( %all_ops; ) &gt;

&lt;!ELEMENT and           ( %all_ops; )+ &gt;

&lt;!ELEMENT or            ( %all_ops; )+ &gt;

&lt;!ELEMENT not           ( %all_ops; ) &gt;

&lt;!ELEMENT lt            (prop, (literal|typed-literal)) &gt;
&lt;!ATTLIST lt            caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT lte           (prop, (literal|typed-literal)) &gt;
&lt;!ATTLIST lte           caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT gt            (prop, (literal|typed-literal)) &gt;
&lt;!ATTLIST gt            caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT gte           (prop, (literal|typed-literal)) &gt;
&lt;!ATTLIST gte           caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT eq            (prop, (literal|typed-literal)) &gt;
&lt;!ATTLIST eq            caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT literal       (#PCDATA)&gt;
&lt;!ELEMENT typed-literal (#PCDATA)&gt;
&lt;!ATTLIST typed-literal xsi:type CDATA #IMPLIED&gt;

&lt;!ELEMENT is-collection EMPTY &gt;
&lt;!ELEMENT is-defined    (prop) &gt;

&lt;!ELEMENT language-defined    (prop) &gt;
&lt;!ELEMENT language-matches    (prop, literal) &gt;

&lt;!ELEMENT like          (prop, literal) &gt;
&lt;!ATTLIST like          caseless   (yes|no) #IMPLIED&gt;

&lt;!ELEMENT contains      (#PCDATA)&gt;
</pre></div><div id="rfc.figure.u.21"><p id="orderby">&lt;!-- "orderby" element --&gt;</p><pre class="inline prettyprint">&lt;!ELEMENT <a href="#orderby" class="smpl">orderby</a>       (order+) &gt;
&lt;!ELEMENT order         ((prop | score), (ascending | descending)?)&gt;
&lt;!ATTLIST order         caseless   (yes|no) #IMPLIED&gt;
&lt;!ELEMENT ascending     EMPTY&gt;
&lt;!ELEMENT descending    EMPTY&gt;
</pre></div><div id="rfc.figure.u.22"><p id="limit">&lt;!-- "limit" element --&gt;</p><pre class="inline prettyprint">&lt;!ELEMENT <a href="#limit" class="smpl">limit</a>         (nresults) &gt;
&lt;!ELEMENT nresults      (#PCDATA) &gt;
</pre></div><section id="n-example-query"><h4 id="rfc.section.5.2.1"><a href="#rfc.section.5.2.1">5.2.1.</a>&nbsp;<a href="#n-example-query">Example Query</a></h4><div id="rfc.section.5.2.1.p.1"><p>This query retrieves the content length values for all resources located under the server's "/container1/" URI namespace whose length exceeds 10000 sorted ascending by size.<a class="self" href="#rfc.section.5.2.1.p.1">&para;</a></p></div><div id="rfc.figure.u.23"><pre class="text prettyprint">&lt;d:searchrequest xmlns:d="DAV:"&gt;
  &lt;d:basicsearch&gt;
    &lt;d:select&gt;
      &lt;d:prop&gt;&lt;d:getcontentlength/&gt;&lt;/d:prop&gt;
    &lt;/d:select&gt;
    &lt;d:from&gt;
      &lt;d:scope&gt;
        &lt;d:href&gt;/container1/&lt;/d:href&gt;
        &lt;d:depth&gt;infinity&lt;/d:depth&gt;
      &lt;/d:scope&gt;
    &lt;/d:from&gt;
    &lt;d:where&gt;
      &lt;d:gt&gt; 
        &lt;d:prop&gt;&lt;d:getcontentlength/&gt;&lt;/d:prop&gt;
        &lt;d:literal&gt;10000&lt;/d:literal&gt;
      &lt;/d:gt&gt;
    &lt;/d:where&gt;
    &lt;d:orderby&gt;
      &lt;d:order&gt;
        &lt;d:prop&gt;&lt;d:getcontentlength/&gt;&lt;/d:prop&gt;
        &lt;d:ascending/&gt;
      &lt;/d:order&gt;
    &lt;/d:orderby&gt;
  &lt;/d:basicsearch&gt;
&lt;/d:searchrequest&gt;
</pre></div></section></section><section id="n-dav-select"><h3 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a>&nbsp;<a href="#n-dav-select">DAV:select</a></h3><div id="rfc.section.5.3.p.1"><p>DAV:select defines the result record, which is a set of properties and values. This document defines two possible values: DAV:allprop and DAV:prop, both defined in <a href="https://tools.ietf.org/html/rfc4918#section-14">Section 14</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.12"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>.<a class="self" href="#rfc.section.5.3.p.1">&para;</a></p></div></section><section id="n-dav-from"><h3 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a>&nbsp;<a href="#n-dav-from">DAV:from</a></h3><div id="rfc.figure.u.24"><pre class="inline prettyprint">&lt;!ELEMENT scope            (href, depth, include-versions?) &gt;
&lt;!ELEMENT include-versions EMPTY &gt;
</pre></div><div id="rfc.section.5.4.p.1"><p>DAV:from defines the query scope. This contains one or more DAV:scope elements. Support for multiple scope elements is optional, however servers <em class="bcp14">MUST</em> fail a request specifying multiple DAV:scope elements if they can't support it (see <a href="#request.body" title="The Request Body">Section&nbsp;2.2.2</a>, precondition DAV:search-multiple-scope-supported). The scope element contains mandatory DAV:href and DAV:depth elements.<a class="self" href="#rfc.section.5.4.p.1">&para;</a></p></div><div id="rfc.section.5.4.p.2"><p>DAV:href indicates the URI reference (<a href="#RFC3986" id="rfc.xref.RFC3986.1"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="https://tools.ietf.org/html/rfc3986#section-4.1">Section 4.1</a>) to use as a scope.<a class="self" href="#rfc.section.5.4.p.2">&para;</a></p></div><div id="rfc.section.5.4.p.3"><p>When the scope is a collection, if DAV:depth is "0", the search includes only the collection. When it is "1", the search includes the collection and its immediate children. When it is "infinity", it includes the collection and all its progeny.<a class="self" href="#rfc.section.5.4.p.3">&para;</a></p></div><div id="rfc.section.5.4.p.4"><p>When the scope is not a collection, the depth is ignored and the search applies just to the resource itself.<a class="self" href="#rfc.section.5.4.p.4">&para;</a></p></div><div id="rfc.section.5.4.p.5"><p>If the server supports WebDAV Redirect Reference Resources (<a href="#RFC4437" id="rfc.xref.RFC4437.1"><cite title="Web Distributed Authoring and Versioning (WebDAV) Redirect&nbsp;Reference&nbsp;Resources">[RFC4437]</cite></a>) and the search scope contains a redirect reference resource, then it applies only to that resource, not to its target.<a class="self" href="#rfc.section.5.4.p.5">&para;</a></p></div><div id="rfc.section.5.4.p.6"><p>When the child element DAV:include-versions is present, the search scope will include all versions (see <a href="#RFC3253" id="rfc.xref.RFC3253.5"><cite title="Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)">[RFC3253]</cite></a>, <a href="https://tools.ietf.org/html/rfc3253#section-2.2.1">Section 2.2.1</a>) of all version-controlled resources in scope. Servers that do support versioning but do not support the DAV:include-versions feature <em class="bcp14">MUST</em> signal an error if it is used in a query (see <a href="#request.body" title="The Request Body">Section&nbsp;2.2.2</a>, precondition DAV:search-scope-valid).<a class="self" href="#rfc.section.5.4.p.6">&para;</a></p></div><section id="n-relationship-to-the-request-uri"><h4 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a>&nbsp;<a href="#n-relationship-to-the-request-uri">Relationship to the Request-URI</a></h4><div id="rfc.section.5.4.1.p.1"><p>If the DAV:scope element is a URI (<a href="#RFC3986" id="rfc.xref.RFC3986.2"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="https://tools.ietf.org/html/rfc3986#section-3">Section 3</a>), the scope is exactly that URI.<a class="self" href="#rfc.section.5.4.1.p.1">&para;</a></p></div><div id="rfc.section.5.4.1.p.2"><p>If the DAV:scope element is a relative reference (<a href="#RFC3986" id="rfc.xref.RFC3986.3"><cite title="Uniform Resource Identifier (URI): Generic Syntax">[RFC3986]</cite></a>, <a href="https://tools.ietf.org/html/rfc3986#section-4.2">Section 4.2</a>), the scope is taken to be relative to the Request-URI.<a class="self" href="#rfc.section.5.4.1.p.2">&para;</a></p></div></section><section id="n-scope"><h4 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a>&nbsp;<a href="#n-scope">Scope</a></h4><div id="rfc.section.5.4.2.p.1"><p>A Scope can be an arbitrary URI reference.<a class="self" href="#rfc.section.5.4.2.p.1">&para;</a></p></div><div id="rfc.section.5.4.2.p.2"><p>Servers, of course, may support only particular scopes. This may include limitations for particular schemes such as "http:" or "ftp:" or certain URI namespaces. However, WebDAV-compliant search arbiters minimally <em class="bcp14">SHOULD</em> support scopes that match their own URI.<a class="self" href="#rfc.section.5.4.2.p.2">&para;</a></p></div></section></section><section id="n-dav-where"><h3 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a>&nbsp;<a href="#n-dav-where">DAV:where</a></h3><div id="rfc.section.5.5.p.1"><p>The DAV:where element defines the search condition for inclusion of resources in the result set. The value of this element is an XML element that defines a search operator that evaluates to one of the Boolean truth values TRUE, FALSE, or UNKNOWN. The search operator contained by DAV:where may itself contain and evaluate additional search operators as operands, which in turn may contain and evaluate additional search operators as operands, etc., recursively.<a class="self" href="#rfc.section.5.5.p.1">&para;</a></p></div><section id="n-use-of-three-valued-logic-in-queries"><h4 id="rfc.section.5.5.1"><a href="#rfc.section.5.5.1">5.5.1.</a>&nbsp;<a href="#n-use-of-three-valued-logic-in-queries">Use of Three-Valued Logic in Queries</a></h4><div id="rfc.section.5.5.1.p.1"><p>Each operator defined for use in the where clause that returns a Boolean value <em class="bcp14">MUST</em> evaluate to TRUE, FALSE, or UNKNOWN. The resource under scan is included as a member of the result set if and only if the search condition evaluates to TRUE.<a class="self" href="#rfc.section.5.5.1.p.1">&para;</a></p></div><div id="rfc.section.5.5.1.p.2"><p>Consult <a href="#three-valued-logic" title="Three-Valued Logic in DAV:basicsearch">Appendix&nbsp;A</a> for details on the application of three-valued logic in query expressions.<a class="self" href="#rfc.section.5.5.1.p.2">&para;</a></p></div></section><section id="n-handling-optional-operators"><h4 id="rfc.section.5.5.2"><a href="#rfc.section.5.5.2">5.5.2.</a>&nbsp;<a href="#n-handling-optional-operators">Handling Optional Operators</a></h4><div id="rfc.section.5.5.2.p.1"><p>If a query contains an operator that is not supported by the server, then the server <em class="bcp14">MUST</em> respond with a 422 (Unprocessable Entity) status code.<a class="self" href="#rfc.section.5.5.2.p.1">&para;</a></p></div></section><section id="null-values"><h4 id="rfc.section.5.5.3"><a href="#rfc.section.5.5.3">5.5.3.</a>&nbsp;<a href="#null-values">Treatment of NULL Values</a></h4><div id="rfc.section.5.5.3.p.1"><p>If a PROPFIND for a property value would yield a non-2xx (see <a href="https://tools.ietf.org/html/rfc2616#section-10.2">Section 10.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.7"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a>) response for that property, then that property is considered NULL.<a class="self" href="#rfc.section.5.5.3.p.1">&para;</a></p></div><div id="rfc.section.5.5.3.p.2"><p>NULL values are "less than" all other values in comparisons.<a class="self" href="#rfc.section.5.5.3.p.2">&para;</a></p></div><div id="rfc.section.5.5.3.p.3"><p>Empty strings (zero length strings) are not NULL values. An empty string is "less than" a string with length greater than zero.<a class="self" href="#rfc.section.5.5.3.p.3">&para;</a></p></div><div id="rfc.section.5.5.3.p.4"><p>The DAV:is-defined operator is defined to test if the value of a property is not NULL.<a class="self" href="#rfc.section.5.5.3.p.4">&para;</a></p></div></section><section id="non-simple-types"><h4 id="rfc.section.5.5.4"><a href="#rfc.section.5.5.4">5.5.4.</a>&nbsp;<a href="#non-simple-types">Treatment of Properties with Mixed/Element Content</a></h4><div id="rfc.section.5.5.4.p.1"><p>Comparisons of properties that do not have simple types (text-only content) is out of scope for the standard operators defined for DAV:basicsearch and therefore is defined to be UNKNOWN (as per <a href="#three-valued-logic" title="Three-Valued Logic in DAV:basicsearch">Appendix&nbsp;A</a>). For querying the DAV:resourcetype property, see <a href="#OPERATOR_is-collection" title="DAV:is-collection">Section&nbsp;5.13</a>.<a class="self" href="#rfc.section.5.5.4.p.1">&para;</a></p></div></section><section id="n-example--testing-for-equality"><h4 id="rfc.section.5.5.5"><a href="#rfc.section.5.5.5">5.5.5.</a>&nbsp;<a href="#n-example--testing-for-equality">Example: Testing for Equality</a></h4><div id="rfc.section.5.5.5.p.1"><p>The example shows a single operator (DAV:eq) applied in the criteria.<a class="self" href="#rfc.section.5.5.5.p.1">&para;</a></p></div><div id="rfc.figure.u.25"><pre class="text prettyprint">&lt;d:where xmlns:d='DAV:'&gt;
  &lt;d:eq&gt;
    &lt;d:prop&gt;
      &lt;d:getcontentlength/&gt;
    &lt;/d:prop&gt;
    &lt;d:literal&gt;100&lt;/d:literal&gt;
  &lt;/d:eq&gt;
&lt;/d:where&gt;</pre></div></section><section id="n-example--relative-comparisons"><h4 id="rfc.section.5.5.6"><a href="#rfc.section.5.5.6">5.5.6.</a>&nbsp;<a href="#n-example--relative-comparisons">Example: Relative Comparisons</a></h4><div id="rfc.section.5.5.6.p.1"><p>The example shows a more complex operation involving several operators (DAV:and, DAV:eq, DAV:gt) applied in the criteria. This DAV:where expression matches those resources of type "image/gif" over 4K in size.<a class="self" href="#rfc.section.5.5.6.p.1">&para;</a></p></div><div id="rfc.figure.u.26"><pre class="text prettyprint">&lt;D:where xmlns:D='DAV:'&gt;
  &lt;D:and&gt;
    &lt;D:eq&gt;
      &lt;D:prop&gt;
        &lt;D:getcontenttype/&gt;
      &lt;/D:prop&gt;
      &lt;D:literal&gt;image/gif&lt;/D:literal&gt;
    &lt;/D:eq&gt;
    &lt;D:gt&gt;
      &lt;D:prop&gt;
        &lt;D:getcontentlength/&gt;
      &lt;/D:prop&gt;
      &lt;D:literal&gt;4096&lt;/D:literal&gt;
    &lt;/D:gt&gt;
  &lt;/D:and&gt;
&lt;/D:where&gt;</pre></div></section></section><section id="n-dav-orderby"><h3 id="rfc.section.5.6"><a href="#rfc.section.5.6">5.6.</a>&nbsp;<a href="#n-dav-orderby">DAV:orderby</a></h3><div id="rfc.section.5.6.p.1"><p>The DAV:orderby element specifies the ordering of the result set. It contains one or more DAV:order elements, each of which specifies a comparison between two items in the result set. Informally, a comparison specifies a test that determines whether one resource appears before another in the result set. Comparisons are applied in the order they occur in the DAV:orderby element, earlier comparisons being more significant.<a class="self" href="#rfc.section.5.6.p.1">&para;</a></p></div><div id="rfc.section.5.6.p.2"><p>The comparisons defined here use only a single property from each resource, compared using the same ordering as the DAV:lt operator (ascending<span id="rfc.iref.d.5"></span>) or DAV:gt operator (descending<span id="rfc.iref.d.6"></span>). If neither direction is specified, the default is DAV:ascending.<a class="self" href="#rfc.section.5.6.p.2">&para;</a></p></div><div id="rfc.section.5.6.p.3"><p>In the context of the DAV:orderby element, null values are considered to collate before any actual (i.e., non-null) value, including strings of zero length (this is compatible with <a href="#SQL99" id="rfc.xref.SQL99.1"><cite title="Database Language SQL Part 2: Foundation (SQL/Foundation)">[SQL99]</cite></a>).<a class="self" href="#rfc.section.5.6.p.3">&para;</a></p></div><div id="rfc.section.5.6.p.4"><p><span id="rfc.iref.c.6"></span> The "caseless" attribute may be used to indicate case-sensitivity for comparisons (<a href="#caseless" title="The 'caseless' XML Attribute">Section&nbsp;5.18</a>).<a class="self" href="#rfc.section.5.6.p.4">&para;</a></p></div><section id="n-example-of-sorting"><h4 id="rfc.section.5.6.1"><a href="#rfc.section.5.6.1">5.6.1.</a>&nbsp;<a href="#n-example-of-sorting">Example of Sorting</a></h4><div id="rfc.section.5.6.1.p.1"><p>This sort orders first by last name of the author and then by size, in descending order, so that for each author, the largest works appear first.<a class="self" href="#rfc.section.5.6.1.p.1">&para;</a></p></div><div id="rfc.figure.u.27"><pre class="text prettyprint">&lt;d:orderby xmlns:d='DAV:' xmlns:r='http://example.com/ns'&gt;
  &lt;d:order&gt;
    &lt;d:prop&gt;&lt;r:lastname/&gt;&lt;/d:prop&gt;
    &lt;d:ascending/&gt;
  &lt;/d:order&gt;
  &lt;d:order&gt;
    &lt;d:prop&gt;&lt;d:getcontentlength/&gt;&lt;/d:prop&gt;
    &lt;d:descending/&gt;
  &lt;/d:order&gt;
&lt;/d:orderby&gt;</pre></div></section></section><section id="n-boolean-operators--dav-and--dav-or--and-dav-not"><h3 id="rfc.section.5.7"><a href="#rfc.section.5.7">5.7.</a>&nbsp;<a href="#n-boolean-operators--dav-and--dav-or--and-dav-not">Boolean Operators: DAV:and, DAV:or, and DAV:not</a></h3><div id="rfc.section.5.7.p.1"><p>The DAV:and operator performs a logical AND operation on the expressions it contains.<a class="self" href="#rfc.section.5.7.p.1">&para;</a></p></div><div id="rfc.iref.d.7"></div><div id="rfc.section.5.7.p.2"><p>The DAV:or operator performs a logical OR operation on the values it contains.<a class="self" href="#rfc.section.5.7.p.2">&para;</a></p></div><div id="rfc.iref.d.8"></div><div id="rfc.section.5.7.p.3"><p>The DAV:not operator performs a logical NOT operation on the values it contains.<a class="self" href="#rfc.section.5.7.p.3">&para;</a></p></div></section><section id="n-dav-eq"><h3 id="rfc.section.5.8"><a href="#rfc.section.5.8">5.8.</a>&nbsp;<a href="#n-dav-eq">DAV:eq</a></h3><div id="rfc.section.5.8.p.1"><p>The DAV:eq operator provides simple equality matching on property values.<a class="self" href="#rfc.section.5.8.p.1">&para;</a></p></div><div id="rfc.iref.d.9"></div><div id="rfc.iref.c.7"></div><div id="rfc.section.5.8.p.2"><p>The "caseless" attribute may be used with this element (<a href="#caseless" title="The 'caseless' XML Attribute">Section&nbsp;5.18</a>).<a class="self" href="#rfc.section.5.8.p.2">&para;</a></p></div></section><section id="n-dav-lt--dav-lte--dav-gt--dav-gte"><h3 id="rfc.section.5.9"><a href="#rfc.section.5.9">5.9.</a>&nbsp;<a href="#n-dav-lt--dav-lte--dav-gt--dav-gte">DAV:lt, DAV:lte, DAV:gt, DAV:gte</a></h3><div id="rfc.section.5.9.p.1"><p>The DAV:lt, DAV:lte, DAV:gt, and DAV:gte operators provide comparisons on property values, using less-than, less-than or equal, greater-than, and greater-than or equal, respectively. The "caseless" attribute may be used with these elements (<a href="#caseless" title="The 'caseless' XML Attribute">Section&nbsp;5.18</a>).<a class="self" href="#rfc.section.5.9.p.1">&para;</a></p></div></section><section id="n-dav-literal"><h3 id="rfc.section.5.10"><a href="#rfc.section.5.10">5.10.</a>&nbsp;<a href="#n-dav-literal">DAV:literal</a></h3><div id="rfc.section.5.10.p.1"><p>DAV:literal allows literal values to be placed in an expression.<a class="self" href="#rfc.section.5.10.p.1">&para;</a></p></div><div id="rfc.section.5.10.p.2"><p>White space in literal values is significant in comparisons. For consistency with <a href="#RFC4918" id="rfc.xref.RFC4918.13"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, clients <em class="bcp14">SHOULD NOT</em> specify the attribute "xml:space" (<a href="http://www.w3.org/TR/2006/REC-xml-20060816#sec-white-space">Section 2.10</a> of <a href="#XML" id="rfc.xref.XML.2"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a>) to override this behavior.<a class="self" href="#rfc.section.5.10.p.2">&para;</a></p></div><div id="rfc.section.5.10.p.3"><p>In comparisons, the contents of DAV:literal <em class="bcp14">SHOULD</em> be treated as string, with the following exceptions: <a class="self" href="#rfc.section.5.10.p.3">&para;</a></p><ul><li>when operand for a comparison with a DAV:getcontentlength property, it <em class="bcp14">SHOULD</em> be treated as an unsigned integer value (the behavior for values not in this format is undefined),</li><li>when operand for a comparison with a DAV:creationdate or DAV:getlastmodified property, it <em class="bcp14">SHOULD</em> be treated as a date value in the ISO-8601 subset defined for the DAV:creationdate property (see <a href="https://tools.ietf.org/html/rfc4918#section-15.1">Section 15.1</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.14"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>; the behavior of values not in this format is undefined),</li><li>when operand for a comparison with a property for which the type is known and when compatible with that type, it <em class="bcp14">MAY</em> be treated according to this type.</li></ul></div></section><section id="n-dav-typed-literal--optional-"><h3 id="rfc.section.5.11"><a href="#rfc.section.5.11">5.11.</a>&nbsp;<a href="#n-dav-typed-literal--optional-">DAV:typed-literal (Optional)</a></h3><div id="rfc.section.5.11.p.1"><p>There are situations in which a client may want to force a comparison not to be string-based (as defined for DAV:literal). In these cases, a typed comparison can be enforced by using DAV:typed-literal instead.<a class="self" href="#rfc.section.5.11.p.1">&para;</a></p></div><div id="rfc.figure.u.28"><pre class="inline prettyprint">&lt;!ELEMENT typed-literal (#PCDATA)&gt;
</pre></div><div id="rfc.section.5.11.p.2"><p>The data type is specified using the xsi:type attribute defined in <a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#xsi_type">Section 2.6.1</a> of <a href="#XS1" id="rfc.xref.XS1.1"><cite title="XML Schema Part 1: Structures">[XS1]</cite></a>. If the type is not specified, it defaults to "xs:string".<a class="self" href="#rfc.section.5.11.p.2">&para;</a></p></div><div id="rfc.section.5.11.p.3"><p>A server <em class="bcp14">MUST</em> reject a request using an unknown type with a status of 422 (Unprocessable Entity). It <em class="bcp14">SHOULD</em> reject a request if the value provided in DAV:typed-literal cannot be cast to the specified type.<a class="self" href="#rfc.section.5.11.p.3">&para;</a></p></div><div id="rfc.section.5.11.p.4"><p>The comparison evaluates to UNKNOWN if the property value cannot be cast to the specified datatype (see <a href="#XPATHFUNC" id="rfc.xref.XPATHFUNC.1"><cite title="XQuery 1.0 and XPath 2.0 Functions and Operators">[XPATHFUNC]</cite></a>, <a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/#casting">Section 17</a>).<a class="self" href="#rfc.section.5.11.p.4">&para;</a></p></div><section id="n-example-for-typed-numerical-comparison"><h4 id="rfc.section.5.11.1"><a href="#rfc.section.5.11.1">5.11.1.</a>&nbsp;<a href="#n-example-for-typed-numerical-comparison">Example for Typed Numerical Comparison</a></h4><div id="rfc.section.5.11.1.p.1" class="avoidbreakafter"><p>Consider a set of resources with the dead property "edits" in the namespace "http://ns.example.org":<a class="self" href="#rfc.section.5.11.1.p.1">&para;</a></p></div><div id="rfc.table.u.1" class="tt"><table class="tt full tcenter"><thead><tr><th>URI</th><th>property value</th></tr></thead><tbody><tr><td class="left">/a</td><td class="left">"-1"</td></tr><tr><td class="left">/b</td><td class="left">"01"</td></tr><tr><td class="left">/c</td><td class="left">"3"</td></tr><tr><td class="left">/d</td><td class="left">"test"</td></tr><tr><td class="left">/e</td><td class="left">(undefined)</td></tr></tbody></table></div><div id="rfc.section.5.11.1.p.2"><p>The expression<a class="self" href="#rfc.section.5.11.1.p.2">&para;</a></p></div><div id="rfc.figure.u.29"><pre class="text prettyprint">&lt;lt xmlns="DAV:"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;prop&gt;&lt;edits xmlns="http://ns.example.org"/&gt;&lt;/prop&gt;
  &lt;typed-literal xsi:type="xs:integer"&gt;3&lt;/typed-literal&gt;
&lt;/lt&gt;
</pre></div><div id="rfc.section.5.11.1.p.3"><p>will evaluate to TRUE for the resources "/a" and "/b" (their property values can be parsed as type xs:integer, and the numerical comparison evaluates to true), to FALSE for "/c" (property value is compatible, but numerical comparison evaluates to false), and UNKNOWN for "/d" and "/e" (the property either is undefined, or its value cannot be parsed as xs:integer).<a class="self" href="#rfc.section.5.11.1.p.3">&para;</a></p></div></section></section><section id="n-support-for-matching-xml-lang-attributes-on-properties"><h3 id="rfc.section.5.12"><a href="#rfc.section.5.12">5.12.</a>&nbsp;<a href="#n-support-for-matching-xml-lang-attributes-on-properties">Support for Matching xml:lang Attributes on Properties</a></h3><div id="rfc.section.5.12.p.1"><p>The following two optional operators can be used to express conditions on the language of a property value (as expressed using the xml:lang attribute).<a class="self" href="#rfc.section.5.12.p.1">&para;</a></p></div><section id="operator.language-defined"><h4 id="rfc.section.5.12.1"><a href="#rfc.section.5.12.1">5.12.1.</a>&nbsp;<a href="#operator.language-defined">DAV:language-defined (Optional)</a></h4><div id="rfc.figure.u.30"><pre class="inline prettyprint">&lt;!ELEMENT language-defined (prop)&gt;
</pre></div><div id="rfc.section.5.12.1.p.1"><p>This operator evaluates to TRUE if the language for the value of the given property is known, FALSE if it isn't, and UNKNOWN if the property itself is not defined.<a class="self" href="#rfc.section.5.12.1.p.1">&para;</a></p></div></section><section id="operator.language-matches"><h4 id="rfc.section.5.12.2"><a href="#rfc.section.5.12.2">5.12.2.</a>&nbsp;<a href="#operator.language-matches">DAV:language-matches (Optional)</a></h4><div id="rfc.figure.u.31"><pre class="inline prettyprint">&lt;!ELEMENT language-matches (prop, literal)&gt;
</pre></div><div id="rfc.section.5.12.2.p.1"><p>This operator evaluates to TRUE if the language for the value of the given property is known and matches the language name given in the &lt;literal&gt; element, FALSE if it doesn't match, and UNKNOWN if the property itself is not defined.<a class="self" href="#rfc.section.5.12.2.p.1">&para;</a></p></div><div id="rfc.section.5.12.2.p.2"><p>Languages are considered to match if they are the same, or if the language of the property value is a sublanguage of the language specified in the &lt;literal&gt; element (see <a href="http://www.w3.org/TR/1999/REC-xpath-19991116#function-lang">Section 4.3</a> of <a href="#XPATH" id="rfc.xref.XPATH.1"><cite title="XML Path Language (XPath) Version 1.0">[XPATH]</cite></a>, "lang function").<a class="self" href="#rfc.section.5.12.2.p.2">&para;</a></p></div></section><section id="n-example-of-language-aware-matching"><h4 id="rfc.section.5.12.3"><a href="#rfc.section.5.12.3">5.12.3.</a>&nbsp;<a href="#n-example-of-language-aware-matching">Example of Language-Aware Matching</a></h4><div id="rfc.section.5.12.3.p.1"><p>The expression below will evaluate to TRUE if the property "foobar" exists and its language is either unknown, English, or a sublanguage of English.<a class="self" href="#rfc.section.5.12.3.p.1">&para;</a></p></div><div id="rfc.figure.u.32"><pre class="text prettyprint">&lt;or xmlns="DAV:"&gt;
  &lt;not&gt;
    &lt;language-defined&gt;
      &lt;prop&gt;&lt;foobar/&gt;&lt;/prop&gt;
    &lt;/language-defined&gt;
  &lt;/not&gt;
  &lt;language-matches&gt;
    &lt;prop&gt;&lt;foobar/&gt;&lt;/prop&gt;
    &lt;literal&gt;en&lt;/literal&gt;
  &lt;/language-matches&gt;
&lt;/or&gt;
</pre></div></section></section><section id="OPERATOR_is-collection"><h3 id="rfc.section.5.13"><a href="#rfc.section.5.13">5.13.</a>&nbsp;<a href="#OPERATOR_is-collection">DAV:is-collection</a></h3><div id="rfc.section.5.13.p.1"><p>The DAV:is-collection operator allows clients to determine whether a resource is a collection (that is, whether its DAV:resourcetype element contains the element DAV:collection).<a class="self" href="#rfc.section.5.13.p.1">&para;</a></p></div><div id="rfc.section.5.13.p.2"><p>Rationale: This operator is provided in lieu of defining generic structure queries, which would suffice for this and for many more powerful queries, but seems inappropriate to standardize at this time.<a class="self" href="#rfc.section.5.13.p.2">&para;</a></p></div><section id="n-example-of-dav-is-collection"><h4 id="rfc.section.5.13.1"><a href="#rfc.section.5.13.1">5.13.1.</a>&nbsp;<a href="#n-example-of-dav-is-collection">Example of DAV:is-collection</a></h4><div id="rfc.section.5.13.1.p.1"><p>This example shows a search criterion that picks out all, and only, the resources in the scope that are collections.<a class="self" href="#rfc.section.5.13.1.p.1">&para;</a></p></div><div id="rfc.figure.u.33"><pre class="text prettyprint">&lt;where xmlns="DAV:"&gt;
  &lt;is-collection/&gt;
&lt;/where&gt;</pre></div></section></section><section id="n-dav-is-defined"><h3 id="rfc.section.5.14"><a href="#rfc.section.5.14">5.14.</a>&nbsp;<a href="#n-dav-is-defined">DAV:is-defined</a></h3><div id="rfc.section.5.14.p.1"><p>The DAV:is-defined operator allows clients to determine whether a property is defined on a resource. The meaning of "defined on a resource" is found in <a href="#null-values" title="Treatment of NULL Values">Section&nbsp;5.5.3</a>.<a class="self" href="#rfc.section.5.14.p.1">&para;</a></p></div><div id="rfc.figure.u.34"><p>Example:</p><pre class="text prettyprint">&lt;d:is-defined xmlns:d='DAV:' xmlns:x='http://example.com/ns'&gt;
  &lt;d:prop&gt;&lt;x:someprop/&gt;&lt;/d:prop&gt;
&lt;/d:is-defined&gt;</pre></div></section><section id="n-dav-like"><h3 id="rfc.section.5.15"><a href="#rfc.section.5.15">5.15.</a>&nbsp;<a href="#n-dav-like">DAV:like</a></h3><div id="rfc.section.5.15.p.1"><p>The DAV:like is an optional operator intended to give simple wildcard-based pattern matching ability to clients.<a class="self" href="#rfc.section.5.15.p.1">&para;</a></p></div><div id="rfc.section.5.15.p.2"><p>The operator takes two arguments.<a class="self" href="#rfc.section.5.15.p.2">&para;</a></p></div><div id="rfc.section.5.15.p.3"><p>The first argument is a DAV:prop element identifying a single property to evaluate.<a class="self" href="#rfc.section.5.15.p.3">&para;</a></p></div><div id="rfc.section.5.15.p.4"><p>The second argument is a DAV:literal element that gives the pattern matching string.<a class="self" href="#rfc.section.5.15.p.4">&para;</a></p></div><section id="n-syntax-for-the-literal-pattern"><h4 id="rfc.section.5.15.1"><a href="#rfc.section.5.15.1">5.15.1.</a>&nbsp;<a href="#n-syntax-for-the-literal-pattern">Syntax for the Literal Pattern</a></h4><div id="rfc.figure.u.35"><pre class="inline">pattern       = [wildcard] 0*( text [wildcard] )

wildcard      = exactlyone / zeroormore
text          = 1*( character / escapeseq )

exactlyone    = "_"
zeroormore    = "%"
escapechar    = "\"
escapeseq     = escapechar ( exactlyone / zeroormore / escapechar ) 

; character: see <a href="#XML" id="rfc.xref.XML.3"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a>, <a href="http://www.w3.org/TR/2006/REC-xml-20060816#charsets">Section 2.2</a>, minus wildcard / escapechar
character     = HTAB / LF / CR ; whitespace
character     =/ %x20-24 / %x26-5B / %x5D-5E / %x60-D7FF
character     =/ %xE000-FFFD / %x10000-10FFFF
</pre><p>(Note that the ABNF above is defined in terms of Unicode code points (<a href="#UNICODE5" id="rfc.xref.UNICODE5.1"><cite title="The Unicode Standard - Version 5.0">[UNICODE5]</cite></a>); when a query is transmitted as an XML document over WebDAV, these characters are typically encoded in UTF-8 or UTF-16.)</p></div><div id="rfc.section.5.15.1.p.1"><p>The value for the literal is composed of wildcards separated by segments of text. Wildcards may begin or end the literal.<a class="self" href="#rfc.section.5.15.1.p.1">&para;</a></p></div><div id="rfc.section.5.15.1.p.2"><p>The "_" wildcard matches exactly one character.<a class="self" href="#rfc.section.5.15.1.p.2">&para;</a></p></div><div id="rfc.section.5.15.1.p.3"><p>The "%" wildcard matches zero or more characters.<a class="self" href="#rfc.section.5.15.1.p.3">&para;</a></p></div><div id="rfc.section.5.15.1.p.4"><p>The "\" character is an escape sequence so that the literal can include "_" and "%". To include the "\" character in the pattern, the escape sequence "\\" is used.<a class="self" href="#rfc.section.5.15.1.p.4">&para;</a></p></div></section><section id="n-example-of-dav-like"><h4 id="rfc.section.5.15.2"><a href="#rfc.section.5.15.2">5.15.2.</a>&nbsp;<a href="#n-example-of-dav-like">Example of DAV:like</a></h4><div id="rfc.section.5.15.2.p.1"><p>This example shows how a client might use DAV:like to identify those resources whose content type was a subtype of image.<a class="self" href="#rfc.section.5.15.2.p.1">&para;</a></p></div><div id="rfc.figure.u.36"><pre class="text prettyprint">&lt;D:where xmlns:D='DAV:'&gt;
  &lt;D:like caseless="yes"&gt;
    &lt;D:prop&gt;&lt;D:getcontenttype/&gt;&lt;/D:prop&gt;
    &lt;D:literal&gt;image/%&lt;/D:literal&gt;
  &lt;/D:like&gt;
&lt;/D:where&gt;</pre></div></section></section><section id="contains"><h3 id="rfc.section.5.16"><a href="#rfc.section.5.16">5.16.</a>&nbsp;<a href="#contains">DAV:contains</a></h3><div id="rfc.section.5.16.p.1"><p>The DAV:contains operator is an optional operator that provides content-based search capability. This operator implicitly searches against the text content of a resource, not against the content of properties. The DAV:contains operator is intentionally not overly constrained, in order to allow the server to do the best job it can in performing the search.<a class="self" href="#rfc.section.5.16.p.1">&para;</a></p></div><div id="rfc.section.5.16.p.2"><p>The DAV:contains operator evaluates to a Boolean value. It evaluates to TRUE if the content of the resource satisfies the search. Otherwise, it evaluates to FALSE.<a class="self" href="#rfc.section.5.16.p.2">&para;</a></p></div><div id="rfc.section.5.16.p.3"><p>Within the DAV:contains XML element, the client provides a phrase: a single word or whitespace delimited sequence of words. Servers <em class="bcp14">MAY</em> ignore punctuation in a phrase. Case-sensitivity is at the discretion of the server implementation.<a class="self" href="#rfc.section.5.16.p.3">&para;</a></p></div><div id="rfc.section.5.16.p.4"><p>The following non-exhaustive list enumerates things that may or may not be done as part of the search: Phonetic methods such as "soundex" may or may not be used. Word stemming may or may not be performed. Thesaurus expansion of words may or may not be done. Right or left truncation may or may not be performed. The search may be case insensitive or case sensitive. The word or words may or may not be interpreted as names. Multiple words may or may not be required to be adjacent or "near" each other. Multiple words may or may not be required to occur in the same order. Multiple words may or may not be treated as a phrase. The search may or may not be interpreted as a request to find documents "similar" to the string operand. Character canonicalization such as that done by the Unicode collation algorithm may or may not be applied.<a class="self" href="#rfc.section.5.16.p.4">&para;</a></p></div><section id="score"><h4 id="rfc.section.5.16.1"><a href="#rfc.section.5.16.1">5.16.1.</a>&nbsp;<a href="#score">Result Scoring (DAV:score Element)</a></h4><div id="rfc.section.5.16.1.p.1"><p>Servers <em class="bcp14">SHOULD</em> indicate scores for the DAV:contains condition by adding a DAV:score XML element to the DAV:response element. Its value is defined only in the context of a particular query result. The value is a string representing the score, an integer from zero to 10000 inclusive, where a higher value indicates a higher score (e.g., more relevant).<a class="self" href="#rfc.section.5.16.1.p.1">&para;</a></p></div><div id="rfc.figure.u.37"><p>Modified DTD fragment for DAV:propstat:</p><pre class="inline prettyprint">&lt;!ELEMENT response (href, ((href*, status)|(propstat+)),
                    responsedescription?, score?) &gt;
&lt;!ELEMENT score    (#PCDATA) &gt;
</pre></div><div id="rfc.section.5.16.1.p.2"><p>Clients should note that, in general, it is not meaningful to compare the numeric values of scores from two different query results unless both were executed by the same underlying search system on the same collection of resources.<a class="self" href="#rfc.section.5.16.1.p.2">&para;</a></p></div></section><section id="n-ordering-by-score"><h4 id="rfc.section.5.16.2"><a href="#rfc.section.5.16.2">5.16.2.</a>&nbsp;<a href="#n-ordering-by-score">Ordering by Score</a></h4><div id="rfc.section.5.16.2.p.1"><p>To order search results by their score, the DAV:score element may be added as child to the DAV:orderby element (in place of a DAV:prop element).<a class="self" href="#rfc.section.5.16.2.p.1">&para;</a></p></div></section><section id="n-examples"><h4 id="rfc.section.5.16.3"><a href="#rfc.section.5.16.3">5.16.3.</a>&nbsp;<a href="#n-examples">Examples</a></h4><div id="rfc.section.5.16.3.p.1"><p>The example below shows a search for the phrase "Peter Forsberg".<a class="self" href="#rfc.section.5.16.3.p.1">&para;</a></p></div><div id="rfc.section.5.16.3.p.2"><p>Depending on its support for content-based searching, a server <em class="bcp14">MAY</em> treat this as a search for documents that contain the words "Peter" and "Forsberg".<a class="self" href="#rfc.section.5.16.3.p.2">&para;</a></p></div><div id="rfc.figure.u.38"><pre class="text prettyprint">&lt;D:where xmlns:D='DAV:'&gt;
  &lt;D:contains&gt;Peter Forsberg&lt;/D:contains&gt;
&lt;/D:where&gt;</pre></div><div id="rfc.section.5.16.3.p.3"><p>The example below shows a search for resources that contain "Peter" and "Forsberg".<a class="self" href="#rfc.section.5.16.3.p.3">&para;</a></p></div><div id="rfc.figure.u.39"><pre class="text prettyprint">&lt;D:where xmlns:D='DAV:'&gt;
  &lt;D:and&gt;
    &lt;D:contains&gt;Peter&lt;/D:contains&gt;
    &lt;D:contains&gt;Forsberg&lt;/D:contains&gt;
  &lt;/D:and&gt;
&lt;/D:where&gt;</pre></div></section></section><section id="limiting.the.result.set"><h3 id="rfc.section.5.17"><a href="#rfc.section.5.17">5.17.</a>&nbsp;<a href="#limiting.the.result.set">Limiting the Result Set</a></h3><div id="rfc.figure.u.40"><pre class="inline prettyprint">&lt;!ELEMENT limit (nresults) &gt;
&lt;!ELEMENT nresults (#PCDATA)&gt; &lt;!-- only digits --&gt;</pre></div><div id="rfc.section.5.17.p.1"><p>The DAV:limit XML element contains requested limits from the client to limit the size of the reply or amount of effort expended by the server. The DAV:nresults XML element contains a requested maximum number of DAV:response elements to be returned in the response body. The server <em class="bcp14">MAY</em> disregard this limit. The value of this element is an unsigned integer.<a class="self" href="#rfc.section.5.17.p.1">&para;</a></p></div><section id="n-relationship-to-result-ordering"><h4 id="rfc.section.5.17.1"><a href="#rfc.section.5.17.1">5.17.1.</a>&nbsp;<a href="#n-relationship-to-result-ordering">Relationship to Result Ordering</a></h4><div id="rfc.section.5.17.1.p.1"><p>If the result set is both limited by DAV:limit and ordered according to DAV:orderby, the results that are included in the response document <em class="bcp14">SHOULD</em> be those that order highest.<a class="self" href="#rfc.section.5.17.1.p.1">&para;</a></p></div></section></section><section id="caseless"><h3 id="rfc.section.5.18"><a href="#rfc.section.5.18">5.18.</a>&nbsp;<a href="#caseless">The 'caseless' XML Attribute</a></h3><div id="rfc.section.5.18.p.1"><p>The "caseless" attribute allows clients to specify caseless matching behavior instead of character-by-character matching for DAV:basicsearch operators.<a class="self" href="#rfc.section.5.18.p.1">&para;</a></p></div><div id="rfc.section.5.18.p.2"><p>The possible values for "caseless" are "yes" or "no". The default value is server-specified. Caseless matching <em class="bcp14">SHOULD</em> be implemented as defined in <a href="http://www.unicode.org/versions/Unicode5.0.0/ch05.pdf#G21180">Section 5.18</a> of the Unicode Standard (<a href="#UNICODE5" id="rfc.xref.UNICODE5.2"><cite title="The Unicode Standard - Version 5.0">[UNICODE5]</cite></a>).<a class="self" href="#rfc.section.5.18.p.2">&para;</a></p></div><div id="rfc.section.5.18.p.3"><p>Support for the "caseless" attribute is optional. A server should respond with a status of 422 if it is used but cannot be supported.<a class="self" href="#rfc.section.5.18.p.3">&para;</a></p></div></section><section id="qs-basicsearch"><h3 id="rfc.section.5.19"><a href="#rfc.section.5.19">5.19.</a>&nbsp;<a href="#qs-basicsearch">Query Schema for DAV:basicsearch</a></h3><div id="rfc.section.5.19.p.1" class="avoidbreakafter"><p>The DAV:basicsearch grammar defines a search criteria that is a Boolean-valued expression, and allows for an arbitrary set of properties to be included in the result record. The result set may be sorted on a set of property values. Accordingly, the DTD for schema discovery for this grammar allows the server to express:<a class="self" href="#rfc.section.5.19.p.1">&para;</a></p></div><div id="rfc.section.5.19.p.2"><ol><li>the set of properties that may be either searched, returned, or used to sort, and a hint about the data type of such properties.</li><li>the set of optional operators defined by the resource.</li></ol></div><section id="n-dtd-for-dav-basicsearch-qsd"><h4 id="rfc.section.5.19.1"><a href="#rfc.section.5.19.1">5.19.1.</a>&nbsp;<a href="#n-dtd-for-dav-basicsearch-qsd">DTD for DAV:basicsearch QSD</a></h4><div id="rfc.figure.u.41"><pre class="inline prettyprint">&lt;!ELEMENT basicsearchschema  (properties, operators)&gt;
&lt;!ELEMENT any-other-property EMPTY&gt;
&lt;!ELEMENT properties         (propdesc*)&gt;
&lt;!ELEMENT propdesc           ((prop|any-other-property), datatype?,
                              searchable?, selectable?, sortable?,
                              caseless?)&gt;
&lt;!ELEMENT operators          (opdesc*)&gt;
&lt;!ELEMENT opdesc             ANY&gt;
&lt;!ATTLIST opdesc             allow-pcdata (yes|no) #IMPLIED&gt;
&lt;!ELEMENT operand-literal    EMPTY&gt;
&lt;!ELEMENT operand-typed-literal EMPTY&gt;
&lt;!ELEMENT operand-property   EMPTY&gt;
</pre></div><div id="rfc.section.5.19.1.p.1"><p>The DAV:properties element holds a list of descriptions of properties.<a class="self" href="#rfc.section.5.19.1.p.1">&para;</a></p></div><div id="rfc.section.5.19.1.p.2"><p>The DAV:operators element describes the optional operators that may be used in a DAV:where element.<a class="self" href="#rfc.section.5.19.1.p.2">&para;</a></p></div></section><section id="n-dav-propdesc-element"><h4 id="rfc.section.5.19.2"><a href="#rfc.section.5.19.2">5.19.2.</a>&nbsp;<a href="#n-dav-propdesc-element">DAV:propdesc Element</a></h4><div id="rfc.section.5.19.2.p.1"><p>Each instance of a DAV:propdesc element describes the property or properties in the DAV:prop element it contains. All subsequent elements are descriptions that apply to those properties. All descriptions are optional and may appear in any order. Servers <em class="bcp14">SHOULD</em> support all the descriptions defined here, and <em class="bcp14">MAY</em> define others.<a class="self" href="#rfc.section.5.19.2.p.1">&para;</a></p></div><div id="rfc.section.5.19.2.p.2"><p>DASL defines five descriptions. The first, DAV:datatype, provides a hint about the type of the property value, and may be useful to a user interface prompting for a value. The remaining four (DAV:searchable, DAV:selectable, DAV:sortable, and DAV:caseless) identify portions of the query (DAV:where, DAV:select, and DAV:orderby, respectively). If a property has a description for a section, then the server <em class="bcp14">MUST</em> allow the property to be used in that section. These descriptions are optional. If a property does not have such a description, or is not described at all, then the server <em class="bcp14">MAY</em> still allow the property to be used in the corresponding section.<a class="self" href="#rfc.section.5.19.2.p.2">&para;</a></p></div><section id="n-dav-any-other-property"><h5 id="rfc.section.5.19.2.1"><a href="#rfc.section.5.19.2.1">5.19.2.1.</a>&nbsp;<a href="#n-dav-any-other-property">DAV:any-other-property</a></h5><div id="rfc.section.5.19.2.1.p.1"><p>This element can be used in place of DAV:prop to describe properties of WebDAV properties not mentioned in any other DAV:prop element. For instance, this can be used to indicate that all other properties are searchable and selectable without giving details about their types (a typical scenario for dead properties).<a class="self" href="#rfc.section.5.19.2.1.p.1">&para;</a></p></div></section></section><section id="n-the-dav-datatype-property-description"><h4 id="rfc.section.5.19.3"><a href="#rfc.section.5.19.3">5.19.3.</a>&nbsp;<a href="#n-the-dav-datatype-property-description">The DAV:datatype Property Description</a></h4><div id="rfc.section.5.19.3.p.1"><p>The DAV:datatype element contains a single XML element that provides a hint about the domain of the property, which may be useful to a user interface prompting for a value to be used in a query. Data types are identified by an element name. Where appropriate, a server <em class="bcp14">SHOULD</em> use the simple data types defined in <a href="#XS2" id="rfc.xref.XS2.1"><cite title="XML Schema Part 2: Datatypes Second Edition">[XS2]</cite></a>.<a class="self" href="#rfc.section.5.19.3.p.1">&para;</a></p></div><div id="rfc.figure.u.42"><pre class="inline prettyprint">&lt;!ELEMENT datatype ANY &gt;</pre></div><div id="rfc.section.5.19.3.p.2" class="avoidbreakafter"><p>Examples from <a href="#XS2" id="rfc.xref.XS2.2"><cite title="XML Schema Part 2: Datatypes Second Edition">[XS2]</cite></a>, <a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#built-in-datatypes">Section 3</a>:<a class="self" href="#rfc.section.5.19.3.p.2">&para;</a></p></div><div id="rfc.table.u.2" class="tt"><table class="tt full tcenter"><thead><tr><th>Qualified name</th><th>Example</th></tr></thead><tbody><tr><td class="left">xs:boolean</td><td class="left">true, false, 1, 0</td></tr><tr><td class="left">xs:string</td><td class="left">Foobar</td></tr><tr><td class="left">xs:dateTime</td><td class="left">1994-11-05T08:15:5Z</td></tr><tr><td class="left">xs:float</td><td class="left">.314159265358979E+1</td></tr><tr><td class="left">xs:integer</td><td class="left">-259, 23</td></tr></tbody></table></div><div id="rfc.section.5.19.3.p.3"><p>If the data type of a property is not given, then the data type defaults to xs:string.<a class="self" href="#rfc.section.5.19.3.p.3">&para;</a></p></div></section><section id="n-the-dav-searchable-property-description"><h4 id="rfc.section.5.19.4"><a href="#rfc.section.5.19.4">5.19.4.</a>&nbsp;<a href="#n-the-dav-searchable-property-description">The DAV:searchable Property Description</a></h4><div id="rfc.figure.u.43"><pre class="inline prettyprint">&lt;!ELEMENT searchable EMPTY&gt;</pre></div><div id="rfc.section.5.19.4.p.1"><p>If this element is present, then the server <em class="bcp14">MUST</em> allow this property to appear within a DAV:where element where an operator allows a property. Allowing a search does not mean that the property is guaranteed to be defined on every resource in the scope, it only indicates the server's willingness to check.<a class="self" href="#rfc.section.5.19.4.p.1">&para;</a></p></div></section><section id="n-the-dav-selectable-property-description"><h4 id="rfc.section.5.19.5"><a href="#rfc.section.5.19.5">5.19.5.</a>&nbsp;<a href="#n-the-dav-selectable-property-description">The DAV:selectable Property Description</a></h4><div id="rfc.figure.u.44"><pre class="inline prettyprint">&lt;!ELEMENT selectable EMPTY&gt;</pre></div><div id="rfc.section.5.19.5.p.1"><p>This element indicates that the property may appear in the DAV:select element.<a class="self" href="#rfc.section.5.19.5.p.1">&para;</a></p></div></section><section id="n-the-dav-sortable-property-description"><h4 id="rfc.section.5.19.6"><a href="#rfc.section.5.19.6">5.19.6.</a>&nbsp;<a href="#n-the-dav-sortable-property-description">The DAV:sortable Property Description</a></h4><div id="rfc.section.5.19.6.p.1"><p>This element indicates that the property may appear in the DAV:orderby element.<a class="self" href="#rfc.section.5.19.6.p.1">&para;</a></p></div><div id="rfc.figure.u.45"><pre class="inline prettyprint">&lt;!ELEMENT sortable EMPTY&gt;</pre></div></section><section id="n-the-dav-caseless-property-description"><h4 id="rfc.section.5.19.7"><a href="#rfc.section.5.19.7">5.19.7.</a>&nbsp;<a href="#n-the-dav-caseless-property-description">The DAV:caseless Property Description</a></h4><div id="rfc.section.5.19.7.p.1"><p>This element only applies to properties whose data type is "xs:string" and derived data types as per the DAV:datatype property description. Its presence indicates that comparisons performed for searches, and the comparisons for ordering results on the string property will be caseless (the default is character by character).<a class="self" href="#rfc.section.5.19.7.p.1">&para;</a></p></div><div id="rfc.figure.u.46"><pre class="inline prettyprint">&lt;!ELEMENT caseless EMPTY&gt;</pre></div></section><section id="n-the-dav-operators-xml-element"><h4 id="rfc.section.5.19.8"><a href="#rfc.section.5.19.8">5.19.8.</a>&nbsp;<a href="#n-the-dav-operators-xml-element">The DAV:operators XML Element</a></h4><div id="rfc.section.5.19.8.p.1"><p>The DAV:operators element describes every optional operator supported in a query. (Mandatory operators are not listed since they are mandatory and permit no variation in syntax.) All optional operators that are supported <em class="bcp14">MUST</em> be listed in the DAV:operators element.<a class="self" href="#rfc.section.5.19.8.p.1">&para;</a></p></div><div id="rfc.section.5.19.8.p.2"><p>The listing for an operator, contained in an DAV:opdesc element, consists of the operator (as an empty element), followed by one element for each operand. The operand <em class="bcp14">MUST</em> be either DAV:operand-property, DAV:operand-literal, or DAV:operand-typed-literal, which indicate that the operand in the corresponding position is a property, a literal value, or a typed literal value, respectively. If an operator is polymorphic (allows more than one operand syntax) then each permitted syntax <em class="bcp14">MUST</em> be listed separately.<a class="self" href="#rfc.section.5.19.8.p.2">&para;</a></p></div><div id="rfc.section.5.19.8.p.3"><p>The DAV:opdesc element <em class="bcp14">MAY</em> have a "allow-pcdata" attribute (defaulting to "no"). A value of "yes" indicates that the operator can contain character data, as it is the case with DAV:contains (see <a href="#contains" title="DAV:contains">Section&nbsp;5.16</a>). Definition of additional operators using this format is <em class="bcp14">NOT RECOMMENDED</em>.<a class="self" href="#rfc.section.5.19.8.p.3">&para;</a></p></div><div id="rfc.figure.u.47"><pre class="text prettyprint">&lt;operators xmlns='DAV:'&gt;
  &lt;opdesc&gt;
    &lt;like/&gt;&lt;operand-property/&gt;&lt;operand-literal/&gt;
  &lt;/opdesc&gt;
&lt;/operators&gt;
</pre></div></section><section id="example.qsd.basicsearch"><h4 id="rfc.section.5.19.9"><a href="#rfc.section.5.19.9">5.19.9.</a>&nbsp;<a href="#example.qsd.basicsearch">Example of Query Schema for DAV:basicsearch</a></h4><div id="rfc.figure.u.48"><pre class="text prettyprint">&lt;D:basicsearchschema xmlns:D="DAV:"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
  &lt;D:properties&gt;
    &lt;D:propdesc&gt;
      &lt;D:prop&gt;&lt;D:getcontentlength/&gt;&lt;/D:prop&gt;
      &lt;D:datatype&gt;&lt;xs:nonNegativeInteger/&gt;&lt;/D:datatype&gt;
      &lt;D:searchable/&gt;&lt;D:selectable/&gt;&lt;D:sortable/&gt;
    &lt;/D:propdesc&gt;
    &lt;D:propdesc&gt;
      &lt;D:prop&gt;&lt;D:getcontenttype/&gt;&lt;D:displayname/&gt;&lt;/D:prop&gt;
      &lt;D:searchable/&gt;&lt;D:selectable/&gt;&lt;D:sortable/&gt;
    &lt;/D:propdesc&gt;
    &lt;D:propdesc&gt;
      &lt;D:prop&gt;&lt;fstop xmlns="http://ns.example.org"/&gt;&lt;/D:prop&gt;
      &lt;D:selectable/&gt;
    &lt;/D:propdesc&gt;
    &lt;D:propdesc&gt;
      &lt;D:any-other-property/&gt;
      &lt;D:searchable/&gt;&lt;D:selectable/&gt;
    &lt;/D:propdesc&gt;
  &lt;/D:properties&gt;
  &lt;D:operators&gt;
    &lt;D:opdesc&gt;
      &lt;D:like/&gt;&lt;D:operand-property/&gt;&lt;D:operand-literal/&gt;
    &lt;/D:opdesc&gt;
    &lt;D:opdesc allow-pcdata="yes"&gt;
      &lt;D:contains/&gt;
    &lt;/D:opdesc&gt;
  &lt;/D:operators&gt;
&lt;/D:basicsearchschema&gt;</pre></div><div id="rfc.section.5.19.9.p.1"><p>This response lists four properties. The data type of the last three properties is not given, so it defaults to xs:string. All are selectable, and the first three may be searched. All but the last may be used in a sort. Of the optional DAV operators, DAV:contains and DAV:like are supported.<a class="self" href="#rfc.section.5.19.9.p.1">&para;</a></p></div><aside><div id="rfc.section.5.19.9.p.2"><p><b>Note:</b> The schema discovery defined here does not provide for discovery of supported values of the "caseless" attribute. This may require that the reply also list the mandatory operators.<a class="self" href="#rfc.section.5.19.9.p.2">&para;</a></p></div></aside></section></section></section><section id="n-internationalization-considerations"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#n-internationalization-considerations">Internationalization Considerations</a></h2><div id="rfc.section.6.p.1"><p>Properties may be language-tagged using the xml:lang attribute (see <a href="#RFC4918" id="rfc.xref.RFC4918.15"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-4.3">Section 4.3</a>). The optional operators DAV:language-defined (<a href="#operator.language-defined" title="DAV:language-defined (Optional)">Section&nbsp;5.12.1</a>) and DAV:language-matches (<a href="#operator.language-matches" title="DAV:language-matches (Optional)">Section&nbsp;5.12.2</a>) allow the expression of conditions on the language tagging information.<a class="self" href="#rfc.section.6.p.1">&para;</a></p></div></section><section id="n-security-considerations"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a>&nbsp;<a href="#n-security-considerations">Security Considerations</a></h2><div id="rfc.section.7.p.1"><p>This section is provided to detail issues concerning security implications of which DASL applications need to be aware. All of the security considerations of HTTP/1.1 (<a href="#RFC2616" id="rfc.xref.RFC2616.8"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[RFC2616]</cite></a> and WebDAV (<a href="#RFC4918" id="rfc.xref.RFC4918.16"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>) also apply to DASL. In addition, this section will include security risks inherent in the search and retrieval of resource properties and content.<a class="self" href="#rfc.section.7.p.1">&para;</a></p></div><div id="rfc.section.7.p.2"><p>A query <em class="bcp14">MUST NOT</em> allow clients to retrieve information that wouldn't have been available through the GET or PROPFIND methods in the first place. In particular: <a class="self" href="#rfc.section.7.p.2">&para;</a></p><ul><li>Query constraints on WebDAV properties for which the client does not have read access need to be evaluated as if the property did not exist (see <a href="#null-values" title="Treatment of NULL Values">Section&nbsp;5.5.3</a>).</li><li>Query constraints on content (as with DAV:contains, defined in <a href="#contains" title="DAV:contains">Section&nbsp;5.16</a>) for which the client does not have read access need to be evaluated as if a GET would return a 4xx status code.</li></ul></div><div id="rfc.section.7.p.3"><p>A server should prepare for denial-of-service attacks. For example a client may issue a query for which the result set is expensive to calculate or transmit because many resources match or must be evaluated.<a class="self" href="#rfc.section.7.p.3">&para;</a></p></div><section id="n-implications-of-xml-external-entities"><h3 id="rfc.section.7.1"><a href="#rfc.section.7.1">7.1.</a>&nbsp;<a href="#n-implications-of-xml-external-entities">Implications of XML External Entities</a></h3><div id="rfc.section.7.1.p.1"><p>XML supports a facility known as "external entities", defined in <a href="http://www.w3.org/TR/2006/REC-xml-20060816#sec-external-ent">Section 4.2.2</a> of <a href="#XML" id="rfc.xref.XML.4"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a>, which instruct an XML processor to retrieve and perform an inline include of XML located at a particular URI. An external XML entity can be used to append or modify the document type declaration (DTD) associated with an XML document. An external XML entity can also be used to include XML within the content of an XML document. For non-validating XML, such as the XML used in this specification, including an external XML entity is not required by <a href="#XML" id="rfc.xref.XML.5"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a>. However, <a href="#XML" id="rfc.xref.XML.6"><cite title="Extensible Markup Language (XML) 1.0 (Fourth Edition)">[XML]</cite></a> does state that an XML processor may, at its discretion, include the external XML entity.<a class="self" href="#rfc.section.7.1.p.1">&para;</a></p></div><div id="rfc.section.7.1.p.2"><p>External XML entities have no inherent trustworthiness and are subject to all the attacks that are endemic to any HTTP GET request. Furthermore, it is possible for an external XML entity to modify the DTD, and hence affect the final form of an XML document, in the worst case significantly modifying its semantics, or exposing the XML processor to the security risks discussed in <a href="#RFC3023" id="rfc.xref.RFC3023.2"><cite title="XML Media Types">[RFC3023]</cite></a>. Therefore, implementers must be aware that external XML entities should be treated as untrustworthy.<a class="self" href="#rfc.section.7.1.p.2">&para;</a></p></div><div id="rfc.section.7.1.p.3"><p>There is also the scalability risk that would accompany a widely deployed application that made use of external XML entities. In this situation, it is possible that there would be significant numbers of requests for one external XML entity, potentially overloading any server that fields requests for the resource containing the external XML entity.<a class="self" href="#rfc.section.7.1.p.3">&para;</a></p></div></section></section><section id="n-scalability"><h2 id="rfc.section.8"><a href="#rfc.section.8">8.</a>&nbsp;<a href="#n-scalability">Scalability</a></h2><div id="rfc.section.8.p.1"><p>Query grammars are identified by URIs. Applications <em class="bcp14">SHOULD NOT</em> attempt to retrieve these URIs even if they appear to be retrievable (for example, those that begin with "http://").<a class="self" href="#rfc.section.8.p.1">&para;</a></p></div></section><section id="n-iana-considerations"><h2 id="rfc.section.9"><a href="#rfc.section.9">9.</a>&nbsp;<a href="#n-iana-considerations">IANA Considerations</a></h2><div id="rfc.section.9.p.1"><p>This document uses the namespace defined in <a href="https://tools.ietf.org/html/rfc4918#section-21">Section 21</a> of <a href="#RFC4918" id="rfc.xref.RFC4918.17"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a> for XML elements.<a class="self" href="#rfc.section.9.p.1">&para;</a></p></div><section id="n-http-headers"><h3 id="rfc.section.9.1"><a href="#rfc.section.9.1">9.1.</a>&nbsp;<a href="#n-http-headers">HTTP Headers</a></h3><div id="rfc.section.9.1.p.1"><p>This document specifies the HTTP header listed below, which has been added to the permanent HTTP header registry defined in <a href="#RFC3864" id="rfc.xref.RFC3864.1"><cite title="Registration Procedures for Message Header Fields">[RFC3864]</cite></a>.<a class="self" href="#rfc.section.9.1.p.1">&para;</a></p></div><section id="n-dasl_2"><h4 id="rfc.section.9.1.1"><a href="#rfc.section.9.1.1">9.1.1.</a>&nbsp;<a href="#n-dasl_2">DASL</a></h4><div id="rfc.section.9.1.1.p.1"><dl><dt>Header field name:</dt><dd>DASL</dd><dt>Applicable protocol:</dt><dd>http</dd><dt>Status:</dt><dd>standard</dd><dt>Author/Change controller:</dt><dd>IETF</dd><dt>Specification document:</dt><dd>this specification (<a href="#header.dasl" title="The DASL Response Header">Section&nbsp;3.2</a>)</dd></dl></div></section></section></section><section id="contributors"><h2 id="rfc.section.10"><a href="#rfc.section.10">10.</a>&nbsp;<a href="#contributors">Contributors</a></h2><div id="rfc.section.10.p.1"><p>This document is based on prior work on the DASL protocol done by the WebDAV DASL working group until the year 2000 -- namely by Alan Babich, Jim Davis, Rick Henderson, Dale Lowry, Saveen Reddy, Surendra Reddy, and Judith Slein (see &lt;<a href="http://www.webdav.org/dasl/">http://www.webdav.org/dasl/</a>&gt; for the working group's web site, &lt;<a href="http://purl.org/NET/webdav/dasl-references/reqs">http://purl.org/NET/webdav/dasl-references/reqs</a>&gt; for a requirements document, and &lt;<a href="http://purl.org/NET/webdav/dasl-references/dasl-protocol-00">http://purl.org/NET/webdav/dasl-references/dasl-protocol-00</a>&gt; for an early version of the specification).<a class="self" href="#rfc.section.10.p.1">&para;</a></p></div></section><section id="acknowledgements"><h2 id="rfc.section.11"><a href="#rfc.section.11">11.</a>&nbsp;<a href="#acknowledgements">Acknowledgements</a></h2><div id="rfc.section.11.p.1"><p>This document has benefited from thoughtful discussion by Lisa Dusseault, Javier Godoy, Sung Kim, Chris Newman, Elias Sinderson, Martin Wallmer, Keith Wannamaker, Jim Whitehead, and Kevin Wiggen.<a class="self" href="#rfc.section.11.p.1">&para;</a></p></div></section><section id="rfc.references"><h2 id="rfc.section.12"><a href="#rfc.section.12">12.</a> References</h2><section id="rfc.references.1"><h3 id="rfc.section.12.1"><a href="#rfc.section.12.1">12.1.</a> Normative References</h3><dl class="reference"><dt id="RFC2119">[RFC2119]</dt><dd><a href="mailto:sob@harvard.edu">Bradner, S.</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>&#8221;, BCP&nbsp;14, RFC&nbsp;2119, March&nbsp;1997.</dd><dt id="RFC2616">[RFC2616]</dt><dd><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Frystyk, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>&#8221;, RFC&nbsp;2616, June&nbsp;1999.</dd><dt id="RFC3023">[RFC3023]</dt><dd><a href="mailto:mmurata@trl.ibm.co.jp">Murata, M.</a>, <a href="mailto:simonstl@simonstl.com">St. Laurent, S.</a>, and <a href="mailto:dan@dankohn.com">D. Kohn</a>, &#8220;<a href="https://tools.ietf.org/html/rfc3023">XML Media Types</a>&#8221;, RFC&nbsp;3023, January&nbsp;2001.</dd><dt id="RFC3253">[RFC3253]</dt><dd><a href="mailto:geoffrey.clemm@rational.com">Clemm, G.</a>, <a href="mailto:jamsden@us.ibm.com">Amsden, J.</a>, <a href="mailto:tim_ellison@uk.ibm.com">Ellison, T.</a>, <a href="mailto:ckaler@microsoft.com">Kaler, C.</a>, and <a href="mailto:ejw@cse.ucsc.edu">J. Whitehead</a>, &#8220;<a href="https://tools.ietf.org/html/rfc3253">Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)</a>&#8221;, RFC&nbsp;3253, March&nbsp;2002.</dd><dt id="RFC3744">[RFC3744]</dt><dd><a href="mailto:geoffrey.clemm@us.ibm.com">Clemm, G.</a>, <a href="mailto:julian.reschke@greenbytes.de">Reschke, J.</a>, <a href="mailto:eric.sedlar@oracle.com">Sedlar, E.</a>, and <a href="mailto:ejw@cse.ucsc.edu">J. Whitehead</a>, &#8220;<a href="https://tools.ietf.org/html/rfc3744">Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol</a>&#8221;, RFC&nbsp;3744, May&nbsp;2004.</dd><dt id="RFC3986">[RFC3986]</dt><dd><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@gbiv.com">Fielding, R.</a>, and <a href="mailto:LMM@acm.org">L. Masinter</a>, &#8220;<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>&#8221;, STD&nbsp;66, RFC&nbsp;3986, January&nbsp;2005.</dd><dt id="RFC4918">[RFC4918]</dt><dd><a href="mailto:ldusseault@commerce.net">Dusseault, L., Ed.</a>, &#8220;<a href="https://tools.ietf.org/html/rfc4918">HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</a>&#8221;, RFC&nbsp;4918, June&nbsp;2007.</dd><dt id="RFC5234">[RFC5234]</dt><dd><a href="mailto:dcrocker@bbiw.net">Crocker, D., Ed.</a> and <a href="mailto:paul.overell@thus.net">P. Overell</a>, &#8220;<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>&#8221;, STD&nbsp;68, RFC&nbsp;5234, January&nbsp;2008.</dd><dt id="XML">[XML]</dt><dd><a href="mailto:tbray@textuality.com">Bray, T.</a>, <a href="mailto:jeanpa@microsoft.com">Paoli, J.</a>, <a href="mailto:cmsmcq@uic.edu">Sperberg-McQueen, C.</a>, <a href="mailto:eve.maler@east.sun.com">Maler, E.</a>, and <a href="mailto:francois@yergeau.com">F. Yergeau</a>, &#8220;<a href="http://www.w3.org/TR/2006/REC-xml-20060816">Extensible Markup Language (XML) 1.0 (Fourth Edition)</a>&#8221;, W3C&nbsp;REC-xml-20060816, August&nbsp;2006, &lt;<a href="http://www.w3.org/TR/2006/REC-xml-20060816">http://www.w3.org/TR/2006/REC-xml-20060816</a>&gt;.</dd><dt id="XPATH">[XPATH]</dt><dd><a href="mailto:jjc@jclark.com">Clark, J.</a> and <a href="mailto:Steven_DeRose@Brown.edu">S. DeRose</a>, &#8220;<a href="http://www.w3.org/TR/1999/REC-xpath-19991116">XML Path Language (XPath) Version 1.0</a>&#8221;, W3C&nbsp;REC-xpath-19991116, November&nbsp;1999, &lt;<a href="http://www.w3.org/TR/1999/REC-xpath-19991116">http://www.w3.org/TR/1999/REC-xpath-19991116</a>&gt;.</dd><dt id="XPATHFUNC">[XPATHFUNC]</dt><dd><a href="mailto:ashok.malhotra@alum.mit.edu">Malhotra, A.</a>, <a href="mailto:jim.melton@acm.org">Melton, J.</a>, and <a href="mailto:Norman.Walsh@Sun.COM">N. Walsh</a>, &#8220;<a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">XQuery 1.0 and XPath 2.0 Functions and Operators</a>&#8221;, W3C&nbsp;REC-xpath-functions-20070123, January&nbsp;2007, &lt;<a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/">http://www.w3.org/TR/2007/REC-xpath-functions-20070123/</a>&gt;.</dd><dt id="XS1">[XS1]</dt><dd><a href="mailto:ht@cogsci.ed.ac.uk">Thompson, H.</a>, <a href="mailto:David.Beech@oracle.com">Beech, D.</a>, <a href="mailto:murray@muzmo.com">Maloney, M.</a>, <a href="mailto:Noah_Mendelsohn@lotus.com">Mendelsohn, N.</a>, and <a href="http://www.w3c.org">World Wide Web Consortium</a>, &#8220;<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">XML Schema Part 1: Structures</a>&#8221;, W3C&nbsp;REC-xmlschema-1-20041028, October&nbsp;2004, &lt;<a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</a>&gt;.</dd><dt id="XS2">[XS2]</dt><dd><a href="mailto:Paul.V.Biron@kp.org">Biron, P.</a>, <a href="mailto:ashokma@microsoft.com">Malhotra, A.</a>, and <a href="http://www.w3c.org">World Wide Web Consortium</a>, &#8220;<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">XML Schema Part 2: Datatypes Second Edition</a>&#8221;, W3C&nbsp;REC-xmlschema-2-20041028, October&nbsp;2004, &lt;<a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</a>&gt;.</dd></dl></section><section id="rfc.references.2"><h3 id="rfc.section.12.2"><a href="#rfc.section.12.2">12.2.</a> Informative References</h3><dl class="reference"><dt id="BCP47">[BCP47]</dt><dd>Phillips, A. and M. Davis, &#8220;<a href="https://tools.ietf.org/html/rfc4647">Matching of Language Tags</a>&#8221;, BCP&nbsp;47, RFC&nbsp;4647, September&nbsp;2006.</dd><dt id="RFC3864">[RFC3864]</dt><dd>Klyne, G., Nottingham, M., and J. Mogul, &#8220;<a href="https://tools.ietf.org/html/rfc3864">Registration Procedures for Message Header Fields</a>&#8221;, BCP&nbsp;90, RFC&nbsp;3864, September&nbsp;2004.</dd><dt id="RFC4437">[RFC4437]</dt><dd><a href="mailto:ejw@cse.ucsc.edu">Whitehead, J.</a>, <a href="mailto:geoffrey.clemm@us.ibm.com">Clemm, G.</a>, and <a href="mailto:julian.reschke@greenbytes.de">J. Reschke, Ed.</a>, &#8220;<a href="https://tools.ietf.org/html/rfc4437">Web Distributed Authoring and Versioning (WebDAV) Redirect&nbsp;Reference&nbsp;Resources</a>&#8221;, RFC&nbsp;4437, March&nbsp;2006.</dd><dt id="RFC4790">[RFC4790]</dt><dd><a href="mailto:chris.newman@sun.com">Newman, C.</a>, <a href="mailto:duerst@it.aoyama.ac.jp">Duerst, M.</a>, and <a href="mailto:arnt@oryx.com">A. Gulbrandsen</a>, &#8220;<a href="https://tools.ietf.org/html/rfc4790">Internet Application Protocol Collation Registry</a>&#8221;, RFC&nbsp;4790, March&nbsp;2007.</dd><dt id="SQL99">[SQL99]</dt><dd>Milton, J., &#8220;Database Language SQL Part 2: Foundation (SQL/Foundation)&#8221;, ISO&nbsp;ISO/IEC 9075-2:1999 (E), July&nbsp;1999.</dd><dt id="UNICODE5">[UNICODE5]</dt><dd>The Unicode Consortium, &#8220;<a href="http://www.unicode.org/versions/Unicode5.0.0/">The Unicode Standard - Version 5.0</a>&#8221;, Addison-Wesley, November&nbsp;2006, &lt;<a href="http://www.unicode.org/versions/Unicode5.0.0/">http://www.unicode.org/versions/Unicode5.0.0/</a>&gt;.<br><a href="urn:isbn:0321480910">ISBN 0321480910</a></dd><dt id="WEBDAV-BIND">[WEBDAV-BIND]</dt><dd><a href="mailto:geoffrey.clemm@us.ibm.com">Clemm, G.</a>, <a href="mailto:ccjason@us.ibm.com">Crawford, J.</a>, <a href="mailto:julian.reschke@greenbytes.de">Reschke, J., Ed.</a>, and <a href="mailto:ejw@cse.ucsc.edu">J. Whitehead</a>, &#8220;Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)&#8221;, October&nbsp;2008.</dd></dl></section></section><section id="three-valued-logic"><h2 id="rfc.section.A" class="np"><a href="#rfc.section.A">A.</a>&nbsp;<a href="#three-valued-logic">Three-Valued Logic in DAV:basicsearch</a></h2><div id="rfc.section.A.p.1"><p>ANSI standard three-valued logic is used when evaluating the search condition (as defined in the ANSI standard SQL specifications, for example, in ANSI X3.135-1992, Section 8.12, pp. 188-189, Section 8.2, p. 169, General Rule 1)a), etc.).<a class="self" href="#rfc.section.A.p.1">&para;</a></p></div><div id="rfc.section.A.p.2"><p>ANSI standard three-valued logic is undoubtedly the most widely practiced method of dealing with the issues of properties in the search condition not having a value (e.g., being null or not defined) for the resource under scan, and with undefined expressions in the search condition (e.g., division by zero, etc.). Three valued logic works as follows.<a class="self" href="#rfc.section.A.p.2">&para;</a></p></div><div id="rfc.section.A.p.3"><p>Undefined expressions are expressions for which the value of the expression is not defined. Undefined expressions are a completely separate concept from the truth value UNKNOWN, which is, in fact, well defined. Property names and literal constants are considered expressions for purposes of this section. If a property in the current resource under scan has not been set to a value, then the value of that property is undefined for the resource under scan. DASL 1.0 has no arithmetic division operator, but if it did, division by zero would be an undefined arithmetic expression.<a class="self" href="#rfc.section.A.p.3">&para;</a></p></div><div id="rfc.section.A.p.4"><p>If any subpart of an arithmetic, string, or datetime subexpression is undefined, the whole arithmetic, string, or datetime subexpression is undefined.<a class="self" href="#rfc.section.A.p.4">&para;</a></p></div><div id="rfc.section.A.p.5"><p>There are no manifest constants to explicitly represent undefined number, string, or datetime values.<a class="self" href="#rfc.section.A.p.5">&para;</a></p></div><div id="rfc.section.A.p.6"><p>Since a Boolean value is ultimately returned by the search condition, arithmetic, string, and datetime expressions are always arguments to other operators. Examples of operators that convert arithmetic, string, and datetime expressions to Boolean values are the six relational operators ("greater than", "less than", "equals", etc.). If either or both operands of a relational operator have undefined values, then the relational operator evaluates to UNKNOWN. Otherwise, the relational operator evaluates to TRUE or FALSE, depending upon the outcome of the comparison.<a class="self" href="#rfc.section.A.p.6">&para;</a></p></div><div id="rfc.section.A.p.7" class="avoidbreakafter"><p>The Boolean operators DAV:and, DAV:or, and DAV:not are evaluated according to the following rules:<a class="self" href="#rfc.section.A.p.7">&para;</a></p></div><div id="rfc.section.A.p.8"><p>not UNKNOWN = UNKNOWN<a class="self" href="#rfc.section.A.p.8">&para;</a></p></div><div id="rfc.section.A.p.9"><p>UNKNOWN and TRUE = UNKNOWN<a class="self" href="#rfc.section.A.p.9">&para;</a></p></div><div id="rfc.section.A.p.10"><p>UNKNOWN and FALSE = FALSE<a class="self" href="#rfc.section.A.p.10">&para;</a></p></div><div id="rfc.section.A.p.11"><p>UNKNOWN and UNKNOWN = UNKNOWN<a class="self" href="#rfc.section.A.p.11">&para;</a></p></div><div id="rfc.section.A.p.12"><p>UNKNOWN or TRUE = TRUE<a class="self" href="#rfc.section.A.p.12">&para;</a></p></div><div id="rfc.section.A.p.13"><p>UNKNOWN or FALSE = UNKNOWN<a class="self" href="#rfc.section.A.p.13">&para;</a></p></div><div id="rfc.section.A.p.14"><p>UNKNOWN or UNKNOWN = UNKNOWN<a class="self" href="#rfc.section.A.p.14">&para;</a></p></div></section><section id="future.protocol.extensions"><h2 id="rfc.section.B"><a href="#rfc.section.B">B.</a>&nbsp;<a href="#future.protocol.extensions">Candidates for Future Protocol Extensions</a></h2><div id="rfc.section.B.p.1"><p>This section summarizes issues that have been raised during the development of this specification, but for which no resolution could be found with the constraints in place. Future revisions of this specification should revisit these issues, though.<a class="self" href="#rfc.section.B.p.1">&para;</a></p></div><section id="extensions.collations"><h3 id="rfc.section.B.1"><a href="#rfc.section.B.1">B.1.</a>&nbsp;<a href="#extensions.collations">Collation Support</a></h3><div id="rfc.section.B.1.p.1"><p>Matching and sorting of textual data relies on collations. With respect to WebDAV SEARCH, a combination of various design approaches could be used: <a class="self" href="#rfc.section.B.1.p.1">&para;</a></p><ul><li>Require server support for specific collations.</li><li>Require that the server can advertise which collations it supports.</li><li>Allow a client to select the collation to be used.</li></ul></div><div id="rfc.section.B.1.p.2"><p>In practice, the current implementations of WebDAV SEARCH usually rely on backends they do not control, and for which collation information may not be available. To make things worse, implementations of the DAV:basicsearch grammar frequently need to combine data from multiple underlying stores (such as properties and full text content), and thus collation support may vary based on the operator or property.<a class="self" href="#rfc.section.B.1.p.2">&para;</a></p></div><div id="rfc.section.B.1.p.3"><p>Another open issue is what collation formalism to support. At the time of this writing, the two specifications below seem to provide the necessary framework and thus may be the base for future work on collation support in WebDAV SEARCH: <a class="self" href="#rfc.section.B.1.p.3">&para;</a></p><ol><li>"Internet Application Protocol Collation Registry" (<a href="#RFC4790" id="rfc.xref.RFC4790.1"><cite title="Internet Application Protocol Collation Registry">[RFC4790]</cite></a>).</li><li>"XQuery 1.0 and XPath 2.0 Functions and Operators" (<a href="#XPATHFUNC" id="rfc.xref.XPATHFUNC.2"><cite title="XQuery 1.0 and XPath 2.0 Functions and Operators">[XPATHFUNC]</cite></a>, <a href="http://www.w3.org/TR/2007/REC-xpath-functions-20070123/#collations">Section 7.3.1</a>).</li></ol></div></section><section id="extensions.count"><h3 id="rfc.section.B.2"><a href="#rfc.section.B.2">B.2.</a>&nbsp;<a href="#extensions.count">Count</a></h3><div id="rfc.section.B.2.p.1"><p>DAV:basicsearch does not allow a request that returns the count of matching resources.<a class="self" href="#rfc.section.B.2.p.1">&para;</a></p></div><div id="rfc.section.B.2.p.2"><p>A protocol extension would need to extend DAV:select, and also modify the DAV:multistatus response format.<a class="self" href="#rfc.section.B.2.p.2">&para;</a></p></div></section><section id="extensions.diagnostics"><h3 id="rfc.section.B.3"><a href="#rfc.section.B.3">B.3.</a>&nbsp;<a href="#extensions.diagnostics">Diagnostics for Unsupported Queries</a></h3><div id="rfc.section.B.3.p.1"><p>There are many reasons why a given query may not be supported by a server. Query Schema Discovery (<a href="#QSD" title="Query Schema Discovery: QSD">Section&nbsp;4</a>) can be used to discover some constraints, but not all.<a class="self" href="#rfc.section.B.3.p.1">&para;</a></p></div><div id="rfc.section.B.3.p.2"><p>Future revisions should consider the introduction of specific condition codes (<a href="#RFC4918" id="rfc.xref.RFC4918.18"><cite title="HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)">[RFC4918]</cite></a>, <a href="https://tools.ietf.org/html/rfc4918#section-16">Section 16</a>) to these situations.<a class="self" href="#rfc.section.B.3.p.2">&para;</a></p></div></section><section id="extensions.language.matching"><h3 id="rfc.section.B.4"><a href="#rfc.section.B.4">B.4.</a>&nbsp;<a href="#extensions.language.matching">Language Matching</a></h3><div id="rfc.section.B.4.p.1"><p><a href="#operator.language-matches" title="DAV:language-matches (Optional)">Section&nbsp;5.12.2</a> defines language matching in terms of the XPath "lang" function (<a href="#XPATH" id="rfc.xref.XPATH.2"><cite title="XML Path Language (XPath) Version 1.0">[XPATH]</cite></a>, <a href="http://www.w3.org/TR/1999/REC-xpath-19991116#function-lang">Section 4.3</a>). Future revisions should consider building on <a href="#BCP47" id="rfc.xref.BCP47.1"><cite title="Matching of Language Tags">[BCP47]</cite></a> instead.<a class="self" href="#rfc.section.B.4.p.1">&para;</a></p></div></section><section id="extensions.mediatype-match"><h3 id="rfc.section.B.5"><a href="#rfc.section.B.5">B.5.</a>&nbsp;<a href="#extensions.mediatype-match">Matching Media Types</a></h3><div id="rfc.section.B.5.p.1"><p>Matching media types using the DAV:getcontenttype property and the DAV:like operator is hard due to DAV:getcontenttype also allowing parameters. A new operator specifically designed for the purpose of matching media types probably would simplify things a lot. See &lt;<a href="http://lists.w3.org/Archives/Public/www-webdav-dasl/2003OctDec/0109.html">http://lists.w3.org/Archives/Public/www-webdav-dasl/2003OctDec/0109.html</a>&gt; for a specific proposal.<a class="self" href="#rfc.section.B.5.p.1">&para;</a></p></div></section><section id="extensions.query-by-name"><h3 id="rfc.section.B.6"><a href="#rfc.section.B.6">B.6.</a>&nbsp;<a href="#extensions.query-by-name">Query by Name</a></h3><div id="rfc.section.B.6.p.1"><p>DAV:basicsearch operates on the properties (and optionally the contents) of resources, and thus doesn't really allow matching on parts of the resource's URI. See &lt;<a href="http://lists.w3.org/Archives/Public/www-webdav-dasl/2003OctDec/0100.html">http://lists.w3.org/Archives/Public/www-webdav-dasl/2003OctDec/0100.html</a>&gt; for a proposed extension covering this use case.<a class="self" href="#rfc.section.B.6.p.1">&para;</a></p></div></section><section id="extensions.result-paging"><h3 id="rfc.section.B.7"><a href="#rfc.section.B.7">B.7.</a>&nbsp;<a href="#extensions.result-paging">Result Paging</a></h3><div id="rfc.section.B.7.p.1"><p>A frequently discussed feature is the ability to specifically request the "next" set of results, when either the server decided to truncate the result, or the client explicitly asked for a limited set (for instance, using the DAV:limit element defined in <a href="#limiting.the.result.set" title="Limiting the Result Set">Section&nbsp;5.17</a>).<a class="self" href="#rfc.section.B.7.p.1">&para;</a></p></div><div id="rfc.section.B.7.p.2"><p>In this case, it would be desirable if the server could keep the full query result, and provide a new URI identifying a separate result resource, allowing the client to retrieve additional data through GET requests, and remove the result through a DELETE request.<a class="self" href="#rfc.section.B.7.p.2">&para;</a></p></div></section><section id="extensions.search.scope.discovery"><h3 id="rfc.section.B.8"><a href="#rfc.section.B.8">B.8.</a>&nbsp;<a href="#extensions.search.scope.discovery">Search Scope Discovery</a></h3><div id="rfc.section.B.8.p.1"><p>Given a Search Arbiter resource, there's currently no way to discover programmatically the supported sets of search scopes. Future revisions of this specification could specify a scope discovery mechanism, similar to the Query Schema Discovery defined in <a href="#QSD" title="Query Schema Discovery: QSD">Section&nbsp;4</a>.<a class="self" href="#rfc.section.B.8.p.1">&para;</a></p></div></section></section><section id="rfc.index"><h2><a href="#rfc.index">Index</a></h2><p class="noprint"><a href="#rfc.index.B">B</a> <a href="#rfc.index.C">C</a> <a href="#rfc.index.D">D</a> <a href="#rfc.index.M">M</a> <a href="#rfc.index.O">O</a> <a href="#rfc.index.P">P</a> <a href="#rfc.index.Q">Q</a> <a href="#rfc.index.R">R</a> <a href="#rfc.index.S">S</a> <a href="#rfc.index.U">U</a> <a href="#rfc.index.W">W</a> <a href="#rfc.index.X">X</a> </p><div class="print2col"><ul class="ind"><li><a id="rfc.index.B" href="#rfc.index.B"><b>B</b></a><ul><li><em>BCP47</em>&nbsp;&nbsp;<a href="#BCP47"><b>12.2</b></a>, <a href="#rfc.xref.BCP47.1">B.4</a></li></ul></li><li><a id="rfc.index.C" href="#rfc.index.C"><b>C</b></a><ul><li>caseless attribute&nbsp;&nbsp;<a href="#rfc.iref.c.6">5.6</a>, <a href="#rfc.iref.c.7">5.8</a>, <a href="#rfc.section.5.9">5.9</a>, <a href="#rfc.section.5.18"><b>5.18</b></a></li><li>Condition Names&nbsp;&nbsp;<ul><li>DAV:search-grammar-discovery-supported (pre)&nbsp;&nbsp;<a href="#rfc.iref.c.2"><b>2.2.2</b></a></li><li>DAV:search-grammar-supported (pre)&nbsp;&nbsp;<a href="#rfc.iref.c.3"><b>2.2.2</b></a></li><li>DAV:search-multiple-scope-supported (pre)&nbsp;&nbsp;<a href="#rfc.iref.c.4"><b>2.2.2</b></a></li><li>DAV:search-scope-valid (pre)&nbsp;&nbsp;<a href="#rfc.iref.c.5"><b>2.2.2</b></a></li></ul></li><li>Criteria&nbsp;&nbsp;<a href="#rfc.iref.c.1"><b>1.3</b></a></li></ul></li><li><a id="rfc.index.D" href="#rfc.index.D"><b>D</b></a><ul><li>DAV:and&nbsp;&nbsp;<a href="#rfc.section.5.7"><b>5.7</b></a></li><li>DAV:ascending&nbsp;&nbsp;<a href="#rfc.iref.d.5"><b>5.6</b></a></li><li>DAV:contains&nbsp;&nbsp;<a href="#rfc.section.5.16"><b>5.16</b></a></li><li>DAV:depth&nbsp;&nbsp;<a href="#rfc.section.5.4"><b>5.4</b></a></li><li>DAV:descending&nbsp;&nbsp;<a href="#rfc.iref.d.6"><b>5.6</b></a></li><li>DAV:eq&nbsp;&nbsp;<a href="#rfc.section.5.8"><b>5.8</b></a><ul><li>caseless attribute&nbsp;&nbsp;<a href="#rfc.iref.d.9">5.8</a></li></ul></li><li>DAV:from&nbsp;&nbsp;<a href="#rfc.section.5.4"><b>5.4</b></a></li><li>DAV:gt&nbsp;&nbsp;<a href="#rfc.section.5.9"><b>5.9</b></a></li><li>DAV:gte&nbsp;&nbsp;<a href="#rfc.section.5.9"><b>5.9</b></a></li><li>DAV:include-versions&nbsp;&nbsp;<a href="#rfc.section.5.4"><b>5.4</b></a></li><li>DAV:is-collection&nbsp;&nbsp;<a href="#rfc.section.5.13"><b>5.13</b></a></li><li>DAV:is-defined&nbsp;&nbsp;<a href="#rfc.section.5.14"><b>5.14</b></a></li><li>DAV:language-defined&nbsp;&nbsp;<a href="#rfc.section.5.12.1"><b>5.12.1</b></a></li><li>DAV:language-matches&nbsp;&nbsp;<a href="#rfc.section.5.12.2"><b>5.12.2</b></a></li><li>DAV:like&nbsp;&nbsp;<a href="#rfc.section.5.15"><b>5.15</b></a></li><li>DAV:limit&nbsp;&nbsp;<a href="#rfc.section.5.17"><b>5.17</b></a></li><li>DAV:literal&nbsp;&nbsp;<a href="#rfc.section.5.10"><b>5.10</b></a></li><li>DAV:lt&nbsp;&nbsp;<a href="#rfc.section.5.9"><b>5.9</b></a></li><li>DAV:lte&nbsp;&nbsp;<a href="#rfc.section.5.9"><b>5.9</b></a></li><li>DAV:not&nbsp;&nbsp;<a href="#rfc.iref.d.8"><b>5.7</b></a></li><li>DAV:nresults&nbsp;&nbsp;<a href="#rfc.section.5.17"><b>5.17</b></a></li><li>DAV:or&nbsp;&nbsp;<a href="#rfc.iref.d.7"><b>5.7</b></a></li><li>DAV:orderby&nbsp;&nbsp;<a href="#rfc.section.5.6"><b>5.6</b></a></li><li>DAV:scope&nbsp;&nbsp;<a href="#rfc.section.5.4"><b>5.4</b></a></li><li>DAV:score&nbsp;&nbsp;<a href="#rfc.section.5.16.1"><b>5.16.1</b></a><ul><li>relationship to DAV:orderby&nbsp;&nbsp;<a href="#rfc.section.5.17.1"><b>5.17.1</b></a></li></ul></li><li>DAV:search-grammar-discovery-supported precondition&nbsp;&nbsp;<a href="#rfc.iref.d.1"><b>2.2.2</b></a></li><li>DAV:search-grammar-supported precondition&nbsp;&nbsp;<a href="#rfc.iref.d.2"><b>2.2.2</b></a></li><li>DAV:search-multiple-scope-supported precondition&nbsp;&nbsp;<a href="#rfc.iref.d.3"><b>2.2.2</b></a></li><li>DAV:search-scope-valid precondition&nbsp;&nbsp;<a href="#rfc.iref.d.4"><b>2.2.2</b></a></li><li>DAV:select&nbsp;&nbsp;<a href="#rfc.section.5.3"><b>5.3</b></a></li><li>DAV:supported-query-grammar-set property&nbsp;&nbsp;<a href="#rfc.section.3.3"><b>3.3</b></a></li><li>DAV:typed-literal&nbsp;&nbsp;<a href="#rfc.section.5.11"><b>5.11</b></a></li><li>DAV:where&nbsp;&nbsp;<a href="#rfc.section.5.5"><b>5.5</b></a></li></ul></li><li><a id="rfc.index.M" href="#rfc.index.M"><b>M</b></a><ul><li>Methods&nbsp;&nbsp;<ul><li>SEARCH&nbsp;&nbsp;<a href="#rfc.section.2"><b>2</b></a></li></ul></li></ul></li><li><a id="rfc.index.O" href="#rfc.index.O"><b>O</b></a><ul><li>OPTIONS method&nbsp;&nbsp;<a href="#rfc.section.3.1"><b>3.1</b></a><ul><li>DASL response header&nbsp;&nbsp;<a href="#rfc.section.3.2"><b>3.2</b></a></li></ul></li></ul></li><li><a id="rfc.index.P" href="#rfc.index.P"><b>P</b></a><ul><li>Properties&nbsp;&nbsp;<ul><li>DAV:supported-query-grammar-set&nbsp;&nbsp;<a href="#rfc.section.3.3"><b>3.3</b></a></li></ul></li></ul></li><li><a id="rfc.index.Q" href="#rfc.index.Q"><b>Q</b></a><ul><li>Query&nbsp;&nbsp;<a href="#rfc.iref.q.1"><b>1.3</b></a></li><li>Query Grammar&nbsp;&nbsp;<a href="#rfc.iref.q.2"><b>1.3</b></a></li><li>Query Grammar Discovery&nbsp;&nbsp;<a href="#rfc.section.3"><b>3</b></a><ul><li>using live property&nbsp;&nbsp;<a href="#rfc.section.3.3"><b>3.3</b></a></li><li>using OPTIONS&nbsp;&nbsp;<a href="#rfc.section.3.1"><b>3.1</b></a></li></ul></li><li>Query Schema&nbsp;&nbsp;<a href="#rfc.iref.q.3"><b>1.3</b></a></li></ul></li><li><a id="rfc.index.R" href="#rfc.index.R"><b>R</b></a><ul><li>Result&nbsp;&nbsp;<a href="#rfc.iref.r.1"><b>1.3</b></a></li><li>Result Record&nbsp;&nbsp;<a href="#rfc.iref.r.2"><b>1.3</b></a></li><li>Result Record Definition&nbsp;&nbsp;<a href="#rfc.iref.r.3"><b>1.3</b></a></li><li>Result Set&nbsp;&nbsp;<a href="#rfc.iref.r.4"><b>1.3</b></a></li><li>Result Set Truncation&nbsp;&nbsp;<ul><li>Example&nbsp;&nbsp;<a href="#rfc.iref.r.5"><b>2.3</b></a></li></ul></li><li><em>RFC2119</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2119.1">1.4</a>, <a href="#RFC2119"><b>12.1</b></a></li><li><em>RFC2616</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.1">1.3</a>, <a href="#rfc.xref.RFC2616.2">2.1</a>, <a href="#rfc.xref.RFC2616.3">3.1</a>, <a href="#rfc.xref.RFC2616.4">3.1</a>, <a href="#rfc.xref.RFC2616.5">3.2</a>, <a href="#rfc.xref.RFC2616.6">3.2</a>, <a href="#rfc.xref.RFC2616.7">5.5.3</a>, <a href="#rfc.xref.RFC2616.8">7</a>, <a href="#RFC2616"><b>12.1</b></a><ul><li><em>Section 2.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.5">3.2</a></li><li><em>Section 4.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.6">3.2</a></li><li><em>Section 9.1.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.2">2.1</a></li><li><em>Section 9.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.3">3.1</a></li><li><em>Section 10.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.7">5.5.3</a></li><li><em>Section 14.7</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.4">3.1</a></li></ul></li><li><em>RFC3023</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3023.1">2.2.2</a>, <a href="#rfc.xref.RFC3023.2">7.1</a>, <a href="#RFC3023"><b>12.1</b></a></li><li><em>RFC3253</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3253.1">1.3</a>, <a href="#rfc.xref.RFC3253.2">2.4</a>, <a href="#rfc.xref.RFC3253.3">3</a>, <a href="#rfc.xref.RFC3253.4">3.3</a>, <a href="#rfc.xref.RFC3253.5">5.4</a>, <a href="#RFC3253"><b>12.1</b></a><ul><li><em>Section 1.6</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3253.2">2.4</a></li><li><em>Section 2.2.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3253.5">5.4</a></li></ul></li><li><em>RFC3744</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3744.1">3</a>, <a href="#rfc.xref.RFC3744.2">3.3</a>, <a href="#RFC3744"><b>12.1</b></a></li><li><em>RFC3864</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3864.1">9.1</a>, <a href="#RFC3864"><b>12.2</b></a></li><li><em>RFC3986</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.1">5.4</a>, <a href="#rfc.xref.RFC3986.2">5.4.1</a>, <a href="#rfc.xref.RFC3986.3">5.4.1</a>, <a href="#RFC3986"><b>12.1</b></a><ul><li><em>Section 3</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.2">5.4.1</a></li><li><em>Section 4.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.1">5.4</a></li><li><em>Section 4.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC3986.3">5.4.1</a></li></ul></li><li><em>RFC4437</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4437.1">5.4</a>, <a href="#RFC4437"><b>12.2</b></a></li><li><em>RFC4790</em>&nbsp;&nbsp;<a href="#RFC4790"><b>12.2</b></a>, <a href="#rfc.xref.RFC4790.1">B.1</a></li><li><em>RFC4918</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.1">1.2</a>, <a href="#rfc.xref.RFC4918.2">1.3</a>, <a href="#rfc.xref.RFC4918.3">1.4</a>, <a href="#rfc.xref.RFC4918.4">1.4</a>, <a href="#rfc.xref.RFC4918.5">1.6</a>, <a href="#rfc.xref.RFC4918.6">2.1</a>, <a href="#rfc.xref.RFC4918.7">2.2.1</a>, <a href="#rfc.xref.RFC4918.8">2.2.2</a>, <a href="#rfc.xref.RFC4918.9">2.3</a>, <a href="#rfc.xref.RFC4918.10">3.2</a>, <a href="#rfc.xref.RFC4918.11">4.1</a>, <a href="#rfc.xref.RFC4918.12">5.3</a>, <a href="#rfc.xref.RFC4918.13">5.10</a>, <a href="#rfc.xref.RFC4918.14">5.10</a>, <a href="#rfc.xref.RFC4918.15">6</a>, <a href="#rfc.xref.RFC4918.16">7</a>, <a href="#rfc.xref.RFC4918.17">9</a>, <a href="#RFC4918"><b>12.1</b></a>, <a href="#rfc.xref.RFC4918.18">B.3</a><ul><li><em>Section 4.3</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.15">6</a></li><li><em>Section 10.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.10">3.2</a></li><li><em>Section 13</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.5">1.6</a>, <a href="#rfc.xref.RFC4918.6">2.1</a>, <a href="#rfc.xref.RFC4918.9">2.3</a>, <a href="#rfc.xref.RFC4918.11">4.1</a></li><li><em>Section 14</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.4">1.4</a>, <a href="#rfc.xref.RFC4918.12">5.3</a></li><li><em>Section 15.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.14">5.10</a></li><li><em>Section 15.9</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.7">2.2.1</a></li><li><em>Section 16</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.18">B.3</a></li><li><em>Section 17</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.3">1.4</a></li><li><em>Section 21</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC4918.17">9</a></li></ul></li><li><em>RFC5234</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC5234.1">1.4</a>, <a href="#RFC5234"><b>12.1</b></a></li></ul></li><li><a id="rfc.index.S" href="#rfc.index.S"><b>S</b></a><ul><li>Scope&nbsp;&nbsp;<a href="#rfc.iref.s.1"><b>1.3</b></a></li><li>Search Arbiter&nbsp;&nbsp;<a href="#rfc.iref.s.2"><b>1.3</b></a></li><li>SEARCH method&nbsp;&nbsp;<a href="#rfc.section.2"><b>2</b></a></li><li>Search Modifier&nbsp;&nbsp;<a href="#rfc.iref.s.3"><b>1.3</b></a></li><li>Sort Specification&nbsp;&nbsp;<a href="#rfc.iref.s.4"><b>1.3</b></a></li><li><em>SQL99</em>&nbsp;&nbsp;<a href="#rfc.xref.SQL99.1">5.6</a>, <a href="#SQL99"><b>12.2</b></a></li></ul></li><li><a id="rfc.index.U" href="#rfc.index.U"><b>U</b></a><ul><li><em>UNICODE5</em>&nbsp;&nbsp;<a href="#rfc.xref.UNICODE5.1">5.15.1</a>, <a href="#rfc.xref.UNICODE5.2">5.18</a>, <a href="#UNICODE5"><b>12.2</b></a></li></ul></li><li><a id="rfc.index.W" href="#rfc.index.W"><b>W</b></a><ul><li><em>WEBDAV-BIND</em>&nbsp;&nbsp;<a href="#rfc.xref.WEBDAV-BIND.1">2.3</a>, <a href="#WEBDAV-BIND"><b>12.2</b></a><ul><li><em>Section 3.1</em>&nbsp;&nbsp;<a href="#rfc.xref.WEBDAV-BIND.1">2.3</a></li></ul></li></ul></li><li><a id="rfc.index.X" href="#rfc.index.X"><b>X</b></a><ul><li><em>XML</em>&nbsp;&nbsp;<a href="#rfc.xref.XML.1">1.4</a>, <a href="#rfc.xref.XML.2">5.10</a>, <a href="#rfc.xref.XML.3">5.15.1</a>, <a href="#rfc.xref.XML.4">7.1</a>, <a href="#rfc.xref.XML.5">7.1</a>, <a href="#rfc.xref.XML.6">7.1</a>, <a href="#XML"><b>12.1</b></a><ul><li><em>Section 2.2</em>&nbsp;&nbsp;<a href="#rfc.xref.XML.3">5.15.1</a></li><li><em>Section 2.10</em>&nbsp;&nbsp;<a href="#rfc.xref.XML.2">5.10</a></li><li><em>Section 3.2</em>&nbsp;&nbsp;<a href="#rfc.xref.XML.1">1.4</a></li><li><em>Section 4.2.2</em>&nbsp;&nbsp;<a href="#rfc.xref.XML.4">7.1</a></li></ul></li><li><em>XPATH</em>&nbsp;&nbsp;<a href="#rfc.xref.XPATH.1">5.12.2</a>, <a href="#XPATH"><b>12.1</b></a>, <a href="#rfc.xref.XPATH.2">B.4</a><ul><li><em>Section 4.3</em>&nbsp;&nbsp;<a href="#rfc.xref.XPATH.1">5.12.2</a>, <a href="#rfc.xref.XPATH.2">B.4</a></li></ul></li><li><em>XPATHFUNC</em>&nbsp;&nbsp;<a href="#rfc.xref.XPATHFUNC.1">5.11</a>, <a href="#XPATHFUNC"><b>12.1</b></a>, <a href="#rfc.xref.XPATHFUNC.2">B.1</a><ul><li><em>Section 7.3.1</em>&nbsp;&nbsp;<a href="#rfc.xref.XPATHFUNC.2">B.1</a></li><li><em>Section 17</em>&nbsp;&nbsp;<a href="#rfc.xref.XPATHFUNC.1">5.11</a></li></ul></li><li><em>XS1</em>&nbsp;&nbsp;<a href="#rfc.xref.XS1.1">5.11</a>, <a href="#XS1"><b>12.1</b></a><ul><li><em>Section 2.6.1</em>&nbsp;&nbsp;<a href="#rfc.xref.XS1.1">5.11</a></li></ul></li><li><em>XS2</em>&nbsp;&nbsp;<a href="#rfc.xref.XS2.1">5.19.3</a>, <a href="#rfc.xref.XS2.2">5.19.3</a>, <a href="#XS2"><b>12.1</b></a><ul><li><em>Section 3</em>&nbsp;&nbsp;<a href="#rfc.xref.XS2.2">5.19.3</a></li></ul></li></ul></li></ul></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>Julian F. Reschke</b>
      (editor)
    <br>greenbytes GmbH<br>Hafenweg 16<br>Muenster, NW&nbsp;48155<br>Germany<br>Phone: <a href="tel:+492512807760">+49 251 2807760</a><br>EMail: <a href="mailto:julian.reschke@greenbytes.de">julian.reschke@greenbytes.de</a><br>URI: <a href="http://greenbytes.de/tech/webdav/">http://greenbytes.de/tech/webdav/</a></address><address><b>Surendra Reddy</b><br>Mitrix, Inc.<br>303 Twin Dolphin Drive, Suite 600-37<br>Redwood City, CA&nbsp;94065<br>U.S.A.<br>Phone: <a href="tel:+14085001135">+1 408 500 1135</a><br>EMail: <a href="mailto:Surendra.Reddy@mitrix.com">Surendra.Reddy@mitrix.com</a></address><address><b>Jim Davis</b><br>27 Borden Street<br>Toronto, Ontario&nbsp;M5S 2M8<br>Canada<br>Phone: <a href="tel:+14169295854">+1 416 929 5854</a><br>EMail: <a href="mailto:jrd3@alum.mit.edu">jrd3@alum.mit.edu</a><br>URI: <a href="http://www.econetwork.net/~jdavis">http://www.econetwork.net/~jdavis</a></address><address><b>Alan Babich</b><br>IBM Corporation<br>3565 Harbor Blvd.<br>Costa Mesa, CA&nbsp;92626<br>U.S.A.<br>Phone: <a href="tel:+17143273403">+1 714 327 3403</a><br>EMail: <a href="mailto:ababich@us.ibm.com">ababich@us.ibm.com</a></address></section></body></html>
