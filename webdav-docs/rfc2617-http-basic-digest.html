<!DOCTYPE html>
<html lang="en"><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>HTTP Authentication: Basic and Digest Access Authentication</title><script type="application/javascript">
function getMeta(rfcno, container) {

  var xhr = new XMLHttpRequest();
  xhr.open("GET", "https://tools.ietf.org/draft/rfc" + rfcno + "/state.xml", true);
  xhr.onload = function (e) {
    if (xhr.readyState === 4) {
      if (xhr.status === 200) {
        var doc = xhr.responseXML;
        var info = getChildByName(doc.documentElement, "info");
  
        var cont = document.getElementById(container);
        // empty the container
        while (cont.firstChild) {
          cont.removeChild(myNode.firstChild);
        }      
  
        var c = getChildByName(info, "stdstatus");
        if (c !== null) {
          var bld = newElementWithText("b", c.textContent);
          cont.appendChild(bld);
        }
  
        c = getChildByName(info, "updatedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Updated by: "));
          appendRfcLinks(cont, c.textContent);
        }
  
        c = getChildByName(info, "obsoletedby");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          cont.appendChild(newText("Obsoleted by: "));
          appendRfcLinks(cont, c.textContent);
        }
        
        c = getChildByName(info, "errata");
        if (c !== null) {
          cont.appendChild(newElement("br"));
          var link = newElementWithText("a", "errata");
          link.setAttribute("href", "http://www.rfc-editor.org/errata_search.php?rfc=" + rfcno);
          var errata = newElementWithText("i", "This document has ");
          errata.appendChild(link);
          errata.appendChild(newText("."));
          cont.appendChild(errata);
        }

        cont.style.display = "block";
      } else {
        console.error(xhr.statusText);
      }
    }
  };
  xhr.onerror = function (e) {
    console.error(xhr.status + " " + xhr.statusText);
  };
  xhr.send(null);
}

// DOM helpers
function newElement(name) {
  return document.createElement(name);
}
function newElementWithText(name, txt) {
  var e = document.createElement(name);
  e.appendChild(newText(txt));
  return e;
}
function newText(text) {
  return document.createTextNode(text);
}

function getChildByName(parent, name) {
  if (parent === null) {
    return null;
  }
  else {
    for (var c = parent.firstChild; c !== null; c = c.nextSibling) {
      if (name == c.nodeName) {
        return c;
      }
    }
    return null;
  }
}

function appendRfcLinks(parent, text) {
  var updates = text.split(",");
  for (var i = 0; i < updates.length; i++) {
    var rfc = updates[i].trim();
    if (rfc.substring(0, 3) == "rfc") {
      var link = newElement("a");
      link.setAttribute("href", "http://tools.ietf.org/html/" + rfc);
      link.appendChild(newText(rfc.substring(3)));
      parent.appendChild(link);
    } else {
      parent.appendChild(newText(rfc));
    }
    if (i != updates.length - 1) {
      parent.appendChild(newText(", "));
    }
  }
}
</script><script type="application/javascript">
function anchorRewrite() {
  map = { };
  if (window.location.hash.length >= 1) {
    var fragid = window.location.hash.substr(1);
    if (fragid) {
      if (! document.getElementById(fragid)) {
        var prefix = "rfc.";
        var mapped = map[fragid];
        if (mapped) {
          window.location.hash = mapped;
        } else if (fragid.indexOf("section-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(8);
        } else if (fragid.indexOf("appendix-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(9);
        } else if (fragid.indexOf("s-") == 0) {
          window.location.hash = prefix + "section." + fragid.substring(2);
        } else if (fragid.indexOf("p-") == 0) {
          var r = fragid.substring(2);
          var p = r.indexOf("-");
          if (p >= 0) {
            window.location.hash = prefix + "section." + r.substring(0, p) + ".p." + r.substring(p + 1);
          }
        }
      }
    }  
  }
}
window.addEventListener('hashchange', anchorRewrite);
window.addEventListener('DOMContentLoaded', anchorRewrite);
</script><style type="text/css" title="Xml2Rfc (sans serif)">
a {
  text-decoration: none;
}
a.smpl {
  color: black;
}
a:hover {
  text-decoration: underline;
}
a:active {
  text-decoration: underline;
}
address {
  margin-top: 1em;
  margin-left: 2em;
  font-style: normal;
}
body {
  color: black;
  font-family: cambria, georgia, serif;
  font-size: 12pt;
  margin: 2em auto;
  max-width: 1000px;
}
samp, span.tt, code, pre {
  font-family: consolas, monaco, monospace;
}
cite {
  font-style: normal;
}
dl {
  margin-left: 2em;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: .0em;
}
dl > dd > dl {
  margin-top: 0.5em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}
dl p {
  margin-left: 0em;
}
dl.reference > dt {
  font-weight: bold;
}
dl.reference > dd {
  margin-left: 3.5em;
}
h1 {
  color: green;
  font-size: 150%;
  line-height: 18pt;
  font-weight: bold;
  text-align: center;
  margin-top: 36pt;
  margin-bottom: 0pt;
}
h2 {
  font-size: 130%;
  line-height: 21pt;
  page-break-after: avoid;
}
h2.np {
  page-break-before: always;
}
h3 {
  font-size: 120%;
  line-height: 15pt;
  page-break-after: avoid;
}
h4 {
  font-size: 110%;
  page-break-after: avoid;
}
h5, h6 {
  page-break-after: avoid;
}
h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
  color: black;
}
img {
  margin-left: 3em;
}
li {
  margin-left: 2em;
}
ol {
  margin-left: 2em;
}
ol.la {
  list-style-type: lower-alpha;
}
ol.ua {
  list-style-type: upper-alpha;
}
ol p {
  margin-left: 0em;
}
p {
  margin-left: 2em;
}
pre {
  font-size: 11pt;
  margin-left: 3em;
  background-color: lightyellow;
  padding: .25em;
  page-break-inside: avoid;
}
pre.text2 {
  border-style: dotted;
  border-width: 1px;
  background-color: #f0f0f0;
}
pre.inline {
  background-color: white;
  padding: 0em;
  page-break-inside: auto;
}
pre.text {
  border-style: dotted;
  border-width: 1px;
  background-color: #f8f8f8;
}
pre.drawing {
  border-style: solid;
  border-width: 1px;
  background-color: #f8f8f8;
  padding: 2em;
}
table {
  margin-left: 2em;
}
table.header {
  border-spacing: 1px;
  width: 95%;
  font-size: 11pt;
  color: white;
}
td.top {
  vertical-align: top;
}
td.topnowrap {
  vertical-align: top;
  white-space: nowrap;
}
table.header td {
  background-color: gray;
  width: 50%;
}
table.header a {
  color: white;
}
ul.toc, ul.toc ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
}
ul.toc li {
  line-height: 150%;
  font-weight: bold;
  margin-left: 0em;
}
ul.toc li li {
  line-height: normal;
  font-weight: normal;
  font-size: 11pt;
  margin-left: 0em;
}
li.excluded {
  font-size: 0pt;
}
ul p {
  margin-left: 0em;
}
.filename, h1, h2, h3, h4 {
  font-family: candara, calibri, segoe, optima, arial, sans-serif;
}
ul.ind, ul.ind ul {
  list-style: none;
  margin-left: 1.5em;
  padding-left: 0em;
  page-break-before: avoid;
}
ul.ind li {
  font-weight: bold;
  line-height: 200%;
  margin-left: 0em;
}
ul.ind li li {
  font-weight: normal;
  line-height: 150%;
  margin-left: 0em;
}
.avoidbreakinside {
  page-break-inside: avoid;
}
.avoidbreakafter {
  page-break-after: avoid;
}
.bcp14 {
  font-style: normal;
  text-transform: lowercase;
  font-variant: small-caps;
}
.comment {
  background-color: yellow;
}
.center {
  text-align: center;
}
.error {
  color: red;
  font-style: italic;
  font-weight: bold;
}
.figure {
  font-weight: bold;
  text-align: center;
  font-size: 10pt;
}
.filename {
  color: #333333;
  font-size: 112%;
  font-weight: bold;
  line-height: 21pt;
  text-align: center;
  margin-top: 0pt;
}
.fn {
  font-weight: bold;
}
.left {
  text-align: left;
}
.right {
  text-align: right;
}
.warning {
  font-size: 130%;
  background-color: yellow;
}
.self {
    color: #999999;
    margin-left: .3em;
    text-decoration: none;
    visibility: hidden;
    -webkit-user-select: none; 
    -moz-user-select: none;
    -ms-user-select: none;
}
.self:hover {
    text-decoration: none;
}
p:hover .self {
    visibility: visible;
}
.docstatus {
  border: 1px solid black;
  display: none;
  float: right;
  margin: 2em;
  padding: 1em;
}

@media screen {
  pre.text, pre.text2 {
    width: 69em;
  }
}

@media print {
  .noprint {
    display: none;
  }

  a {
    color: black;
    text-decoration: none;
  }

  table.header {
    width: 90%;
  }

  td.header {
    width: 50%;
    color: black;
    background-color: white;
    vertical-align: top;
    font-size: 110%;
  }

  ul.toc a:last-child::after {
    content: leader('.') target-counter(attr(href), page);
  }

  ul.ind li li a {
    content: target-counter(attr(href), page);
  }

  pre {
    font-size: 10pt;
  }

  .print2col {
    column-count: 2;
    -moz-column-count: 2;
    column-fill: auto;
  }
}
@page {
  @top-left {
       content: "RFC 2617";
  }
  @top-right {
       content: "June 1999";
  }
  @top-center {
       content: "HTTP Authentication";
  }
  @bottom-left {
       content: "Franks, et al.";
  }
  @bottom-center {
       content: "Standards Track";
  }
  @bottom-right {
       content: "[Page " counter(page) "]";
  }
}
@page:first {
    @top-left {
      content: normal;
    }
    @top-right {
      content: normal;
    }
    @top-center {
      content: normal;
    }
}
</style><link rel="Contents" href="#rfc.toc"><link rel="Author" href="#rfc.authors"><link rel="Copyright" href="#rfc.copyright"><link rel="Index" href="#rfc.index"><link rel="Chapter" title="1 Access Authentication" href="#rfc.section.1"><link rel="Chapter" title="2 Basic Authentication Scheme" href="#rfc.section.2"><link rel="Chapter" title="3 Digest Access Authentication Scheme" href="#rfc.section.3"><link rel="Chapter" title="4 Security Considerations" href="#rfc.section.4"><link rel="Chapter" title="5 Sample implementation" href="#rfc.section.5"><link rel="Chapter" title="6 Acknowledgments" href="#rfc.section.6"><link rel="Chapter" href="#rfc.section.7" title="7 References"><link rel="Alternate" title="Authoritative ASCII Version" href="http://www.ietf.org/rfc/rfc2617.txt"><link rel="Help" title="RFC-Editor's Status Page" href="http://www.rfc-editor.org/info/rfc2617"><link rel="Help" title="Additional Information on tools.ietf.org" href="http://tools.ietf.org/html/rfc2617"><meta name="generator" content="http://greenbytes.de/tech/webdav/rfc2629.xslt, Revision 1.840, 2016/11/16 05:32:10, XSLT vendor: SAXON 6.5.5 from Michael Kay http://saxon.sf.net/"><link rel="schema.dcterms" href="http://purl.org/dc/terms/"><meta name="dcterms.creator" content="Franks, J."><meta name="dcterms.creator" content="Hallam-Baker, P.M."><meta name="dcterms.creator" content="Hostetler, J.L."><meta name="dcterms.creator" content="Lawrence, S.D."><meta name="dcterms.creator" content="Leach, P.J."><meta name="dcterms.creator" content="Luotonen, A."><meta name="dcterms.creator" content="Stewart, L."><meta name="dcterms.identifier" content="urn:ietf:rfc:2617"><meta name="dcterms.issued" content="1999-06"><meta name="dct.replaces" content="urn:ietf:rfc:2069"><meta name="dcterms.abstract" content="&#34;HTTP/1.0&#34;, includes the specification for a Basic Access Authentication scheme. This scheme is not considered to be a secure method of user authentication (unless used in conjunction with some external secure system such as SSL ), as the user name and password are passed over the network as cleartext. This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as &#34;Digest Access Authentication&#34;. It is therefore also intended to serve as a replacement for RFC 2069 . Some optional elements specified by RFC 2069 have been removed from this specification due to problems found since its publication; other new elements have been added for compatibility, those new elements have been made optional, but are strongly recommended. Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password); unlike Basic, this verification can be done without sending the password in the clear, which is Basic's biggest weakness. As with most other authentication protocols, the greatest sources of risks are usually found not in the core protocol itself but in policies and procedures surrounding its use."><meta name="dcterms.isPartOf" content="urn:issn:2070-1721"><meta name="description" content="&#34;HTTP/1.0&#34;, includes the specification for a Basic Access Authentication scheme. This scheme is not considered to be a secure method of user authentication (unless used in conjunction with some external secure system such as SSL ), as the user name and password are passed over the network as cleartext. This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as &#34;Digest Access Authentication&#34;. It is therefore also intended to serve as a replacement for RFC 2069 . Some optional elements specified by RFC 2069 have been removed from this specification due to problems found since its publication; other new elements have been added for compatibility, those new elements have been made optional, but are strongly recommended. Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password); unlike Basic, this verification can be done without sending the password in the clear, which is Basic's biggest weakness. As with most other authentication protocols, the greatest sources of risks are usually found not in the core protocol itself but in policies and procedures surrounding its use."></head><body onload="getMeta(2617,&#34;rfc.meta&#34;);"><header><table class="header" id="rfc.headerblock"><tbody><tr><td class="left">Network Working Group</td><td class="right">J. Franks</td></tr><tr><td class="left">Request for Comments: 2617</td><td class="right">Northwestern University, Department of Mathematics</td></tr><tr><td class="left">Obsoletes: <a href="https://tools.ietf.org/html/rfc2069">2069</a></td><td class="right">P. Hallam-Baker</td></tr><tr><td class="left">Category: Standards Track</td><td class="right">Verisign Inc.</td></tr><tr><td class="left"></td><td class="right">J. Hostetler</td></tr><tr><td class="left"></td><td class="right">AbiSource, Inc.</td></tr><tr><td class="left"></td><td class="right">S. Lawrence</td></tr><tr><td class="left"></td><td class="right">Agranat Systems, Inc.</td></tr><tr><td class="left"></td><td class="right">P. Leach</td></tr><tr><td class="left"></td><td class="right">Microsoft Corporation</td></tr><tr><td class="left"></td><td class="right">A. Luotonen</td></tr><tr><td class="left"></td><td class="right">Netscape Communications Corporation</td></tr><tr><td class="left"></td><td class="right">L. Stewart</td></tr><tr><td class="left"></td><td class="right">Open Market, Inc.</td></tr><tr><td class="left"></td><td class="right">June 1999</td></tr></tbody></table><div id="rfc.title"><h1>HTTP Authentication: Basic and Digest Access Authentication</h1></div></header><div id="rfc.meta" class="docstatus"></div><section id="rfc.status"><h2><a href="#rfc.status">Status of this Memo</a></h2><p>This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the &#8220;Internet Official Protocol Standards&#8221; (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.</p></section><section id="rfc.copyrightnotice"><h2><a href="#rfc.copyrightnotice">Copyright Notice</a></h2><p>Copyright &copy; The Internet Society (1999). All Rights Reserved.</p></section><section id="rfc.abstract"><h2><a href="#rfc.abstract">Abstract</a></h2><p>"HTTP/1.0", includes the specification for a Basic Access Authentication scheme. This scheme is not considered to be a secure method of user authentication (unless used in conjunction with some external secure system such as SSL <a href="#RFC2246" id="rfc.xref.RFC2246.1"><cite title="The TLS Protocol Version 1.0">[5]</cite></a>), as the user name and password are passed over the network as cleartext.</p><p>This document also provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as "Digest Access Authentication". It is therefore also intended to serve as a replacement for RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.1"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>. Some optional elements specified by RFC 2069 have been removed from this specification due to problems found since its publication; other new elements have been added for compatibility, those new elements have been made optional, but are strongly recommended.</p><p>Like Basic, Digest access authentication verifies that both parties to a communication know a shared secret (a password); unlike Basic, this verification can be done without sending the password in the clear, which is Basic's biggest weakness. As with most other authentication protocols, the greatest sources of risks are usually found not in the core protocol itself but in policies and procedures surrounding its use.</p></section><hr class="noprint"><nav id="rfc.toc"><h2 class="np"><a href="#rfc.toc">Table of Contents</a></h2><ul class="toc"><li><a href="#rfc.section.1">1.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1">Access Authentication</a><ul><li><a href="#rfc.section.1.1">1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.1.1">Reliance on the HTTP/1.1 Specification</a></li><li><a href="#rfc.section.1.2">1.2</a>&nbsp;&nbsp;&nbsp;<a href="#access.authentication.framework">Access Authentication Framework</a></li></ul></li><li><a href="#rfc.section.2">2.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.2">Basic Authentication Scheme</a></li><li><a href="#rfc.section.3">3.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3">Digest Access Authentication Scheme</a><ul><li><a href="#rfc.section.3.1">3.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1">Introduction</a><ul><li><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.1">Purpose</a></li><li><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.2">Overall Operation</a></li><li><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.3">Representation of digest values</a></li><li><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.1.4">Limitations</a></li></ul></li><li><a href="#rfc.section.3.2">3.2</a>&nbsp;&nbsp;&nbsp;<a href="#specification.of.digest.headers">Specification of Digest Headers</a><ul><li><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;&nbsp;&nbsp;<a href="#the.www-authenticate.response.header">The WWW-Authenticate Response Header</a></li><li><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;&nbsp;&nbsp;<a href="#the.authorization.request.header">The Authorization Request Header</a></li><li><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.2.3">The Authentication-Info Header</a></li></ul></li><li><a href="#rfc.section.3.3">3.3</a>&nbsp;&nbsp;&nbsp;<a href="#digest.operation">Digest Operation</a></li><li><a href="#rfc.section.3.4">3.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.3.4">Security Protocol Negotiation</a></li><li><a href="#rfc.section.3.5">3.5</a>&nbsp;&nbsp;&nbsp;<a href="#specification.of.digest.headers.example">Example</a></li><li><a href="#rfc.section.3.6">3.6</a>&nbsp;&nbsp;&nbsp;<a href="#proxy-authentication.and.proxy-authorization">Proxy-Authentication and Proxy-Authorization</a></li></ul></li><li><a href="#rfc.section.4">4.</a>&nbsp;&nbsp;&nbsp;<a href="#security.considerations">Security Considerations</a><ul><li><a href="#rfc.section.4.1">4.1</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.1">Authentication of Clients using Basic Authentication</a></li><li><a href="#rfc.section.4.2">4.2</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.2">Authentication of Clients using Digest Authentication</a></li><li><a href="#rfc.section.4.3">4.3</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.3">Limited Use Nonce Values</a></li><li><a href="#rfc.section.4.4">4.4</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.4">Comparison of Digest with Basic Authentication</a></li><li><a href="#rfc.section.4.5">4.5</a>&nbsp;&nbsp;&nbsp;<a href="#replay.attacks">Replay Attacks</a></li><li><a href="#rfc.section.4.6">4.6</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.6">Weakness Created by Multiple Authentication Schemes</a></li><li><a href="#rfc.section.4.7">4.7</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.7">Online dictionary attacks</a></li><li><a href="#rfc.section.4.8">4.8</a>&nbsp;&nbsp;&nbsp;<a href="#man.in.the.middle">Man in the Middle</a></li><li><a href="#rfc.section.4.9">4.9</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.9">Chosen plaintext attacks</a></li><li><a href="#rfc.section.4.10">4.10</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.10">Precomputed dictionary attacks</a></li><li><a href="#rfc.section.4.11">4.11</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.11">Batch brute force attacks</a></li><li><a href="#rfc.section.4.12">4.12</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.12">Spoofing by Counterfeit Servers</a></li><li><a href="#rfc.section.4.13">4.13</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.13">Storing passwords</a></li><li><a href="#rfc.section.4.14">4.14</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.4.14">Summary</a></li></ul></li><li><a href="#rfc.section.5">5.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.5">Sample implementation</a></li><li><a href="#rfc.section.6">6.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.section.6">Acknowledgments</a></li><li><a href="#rfc.section.7">7.</a>&nbsp;&nbsp;&nbsp;<a href="#rfc.references">References</a></li><li><a href="#rfc.index">Index</a></li><li><a href="#rfc.authors">Authors' Addresses</a></li><li><a href="#rfc.ipr">Intellectual Property and Copyright Statements</a></li></ul></nav><section id="n-access-authentication"><h2 id="rfc.section.1" class="np"><a href="#rfc.section.1">1.</a>&nbsp;<a href="#n-access-authentication">Access Authentication</a></h2><section id="n-reliance-on-the-http-1.1-specification"><h3 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1</a>&nbsp;<a href="#n-reliance-on-the-http-1.1-specification">Reliance on the HTTP/1.1 Specification</a></h3><div id="rfc.section.1.1.p.1"><p>This specification is a companion to the HTTP/1.1 specification <a href="#RFC2616" id="rfc.xref.RFC2616.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. It uses the augmented BNF section <a href="https://tools.ietf.org/html/rfc2616#section-2.1" title="Augmented BNF" id="rfc.xref.RFC2616.2">2.1</a> of that document, and relies on both the non-terminals defined in that document and other aspects of the HTTP/1.1 specification.<a class="self" href="#rfc.section.1.1.p.1">&para;</a></p></div></section><section id="access.authentication.framework"><h3 id="rfc.section.1.2"><a href="#rfc.section.1.2">1.2</a>&nbsp;<a href="#access.authentication.framework">Access Authentication Framework</a></h3><div id="rfc.section.1.2.p.1"><p>HTTP provides a simple challenge-response authentication mechanism that <em class="bcp14">MAY</em> be used by a server to challenge a client request and by a client to provide authentication information. It uses an extensible, case-insensitive token to identify the authentication scheme, followed by a comma-separated list of attribute-value pairs which carry the parameters necessary for achieving authentication via that scheme.<a class="self" href="#rfc.section.1.2.p.1">&para;</a></p></div><div id="rfc.figure.u.1"><pre class="inline"><span id="rfc.iref.a.1"></span><span id="rfc.iref.a.2"></span>   auth-scheme    = token
   auth-param     = token "=" ( token | quoted-string )
</pre></div><div id="rfc.section.1.2.p.2"><p>The 401 (Unauthorized) response message is used by an origin server to challenge the authorization of a user agent. This response <em class="bcp14">MUST</em> include a WWW-Authenticate header field containing at least one challenge applicable to the requested resource. The 407 (Proxy Authentication Required) response message is used by a proxy to challenge the authorization of a client and <em class="bcp14">MUST</em> include a Proxy-Authenticate header field containing at least one challenge applicable to the proxy for the requested resource.<a class="self" href="#rfc.section.1.2.p.2">&para;</a></p></div><div id="rfc.figure.u.2"><pre class="inline"><span id="rfc.iref.c.1"></span>   challenge   = auth-scheme 1*SP 1#auth-param
</pre></div><div id="rfc.section.1.2.p.3"><p>Note: User agents will need to take special care in parsing the WWW-Authenticate or Proxy-Authenticate header field value if it contains more than one challenge, or if more than one WWW-Authenticate header field is provided, since the contents of a challenge may itself contain a comma-separated list of authentication parameters.<a class="self" href="#rfc.section.1.2.p.3">&para;</a></p></div><div id="rfc.section.1.2.p.4" class="avoidbreakafter"><p>The authentication parameter realm is defined for all authentication schemes:<a class="self" href="#rfc.section.1.2.p.4">&para;</a></p></div><div id="rfc.figure.u.3"><pre class="inline"><span id="rfc.iref.r.1"></span><span id="rfc.iref.r.2"></span>   realm       = "realm" "=" realm-value
   realm-value = quoted-string
</pre></div><div id="rfc.section.1.2.p.5"><p>The realm directive (case-insensitive) is required for all authentication schemes that issue a challenge. The realm value (case-sensitive), in combination with the canonical root URL (the absoluteURI for the server whose abs_path is empty; see section <a href="https://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.3">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.4"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) of the server being accessed, defines the protection space. These realms allow the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme and/or authorization database. The realm value is a string, generally assigned by the origin server, which may have additional semantics specific to the authentication scheme. Note that there may be multiple challenges with the same auth-scheme but different realms.<a class="self" href="#rfc.section.1.2.p.5">&para;</a></p></div><div id="rfc.section.1.2.p.6"><p>A user agent that wishes to authenticate itself with an origin server--usually, but not necessarily, after receiving a 401 (Unauthorized)--<em class="bcp14">MAY</em> do so by including an Authorization header field with the request. A client that wishes to authenticate itself with a proxy--usually, but not necessarily, after receiving a 407 (Proxy Authentication Required)--<em class="bcp14">MAY</em> do so by including a Proxy-Authorization header field with the request. Both the Authorization field value and the Proxy-Authorization field value consist of credentials containing the authentication information of the client for the realm of the resource being requested. The user agent <em class="bcp14">MUST</em> choose to use one of the challenges with the strongest auth-scheme it understands and request credentials from the user based upon that challenge.<a class="self" href="#rfc.section.1.2.p.6">&para;</a></p></div><div id="rfc.figure.u.4"><pre class="inline"><span id="rfc.iref.c.2"></span>   credentials = auth-scheme #auth-param
</pre></div><div id="rfc.section.1.2.p.7"><ul class="empty"><li>Note that many browsers will only recognize Basic and will require that it be the first auth-scheme presented. Servers should only include Basic if it is minimally acceptable.</li></ul></div><div id="rfc.section.1.2.p.8"><p>The protection space determines the domain over which credentials can be automatically applied. If a prior request has been authorized, the same credentials <em class="bcp14">MAY</em> be reused for all other requests within that protection space for a period of time determined by the authentication scheme, parameters, and/or user preference. Unless otherwise defined by the authentication scheme, a single protection space cannot extend outside the scope of its server.<a class="self" href="#rfc.section.1.2.p.8">&para;</a></p></div><div id="rfc.section.1.2.p.9"><p>If the origin server does not wish to accept the credentials sent with a request, it <em class="bcp14">SHOULD</em> return a 401 (Unauthorized) response. The response <em class="bcp14">MUST</em> include a WWW-Authenticate header field containing at least one (possibly new) challenge applicable to the requested resource. If a proxy does not accept the credentials sent with a request, it <em class="bcp14">SHOULD</em> return a 407 (Proxy Authentication Required). The response <em class="bcp14">MUST</em> include a Proxy-Authenticate header field containing a (possibly new) challenge applicable to the proxy for the requested resource.<a class="self" href="#rfc.section.1.2.p.9">&para;</a></p></div><div id="rfc.section.1.2.p.10"><p>The HTTP protocol does not restrict applications to this simple challenge-response mechanism for access authentication. Additional mechanisms <em class="bcp14">MAY</em> be used, such as encryption at the transport level or via message encapsulation, and with additional header fields specifying authentication information. However, these additional mechanisms are not defined by this specification.<a class="self" href="#rfc.section.1.2.p.10">&para;</a></p></div><div id="rfc.section.1.2.p.11"><p>Proxies <em class="bcp14">MUST</em> be completely transparent regarding user agent authentication by origin servers. That is, they must forward the WWW-Authenticate and Authorization headers untouched, and follow the rules found in section <a href="https://tools.ietf.org/html/rfc2616#section-14.8" title="Authorization" id="rfc.xref.RFC2616.5">14.8</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.6"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. Both the Proxy-Authenticate and the Proxy-Authorization header fields are hop-by-hop headers (see section <a href="https://tools.ietf.org/html/rfc2616#section-13.5.1" title="End-to-end and Hop-by-hop Headers" id="rfc.xref.RFC2616.7">13.5.1</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.8"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>).<a class="self" href="#rfc.section.1.2.p.11">&para;</a></p></div></section></section><section id="n-basic-authentication-scheme"><h2 id="rfc.section.2"><a href="#rfc.section.2">2.</a>&nbsp;<a href="#n-basic-authentication-scheme">Basic Authentication Scheme</a></h2><div id="rfc.section.2.p.1"><p>The "basic" authentication scheme is based on the model that the client must authenticate itself with a user-ID and a password for each realm. The realm value should be considered an opaque string which can only be compared for equality with other realms on that server. The server will service the request only if it can validate the user-ID and password for the protection space of the Request-URI. There are no optional authentication parameters.<a class="self" href="#rfc.section.2.p.1">&para;</a></p></div><div id="rfc.section.2.p.2" class="avoidbreakafter"><p>For Basic, the framework above is utilized as follows:<a class="self" href="#rfc.section.2.p.2">&para;</a></p></div><div id="rfc.figure.u.5"><pre class="inline"><span id="rfc.iref.c.3"></span><span id="rfc.iref.c.4"></span>   challenge   = "Basic" realm
   credentials = "Basic" basic-credentials
</pre></div><div id="rfc.section.2.p.3" class="avoidbreakafter"><p>Upon receipt of an unauthorized request for a URI within the protection space, the origin server <em class="bcp14">MAY</em> respond with a challenge like the following:<a class="self" href="#rfc.section.2.p.3">&para;</a></p></div><div id="rfc.figure.u.6"><pre class="text">   WWW-Authenticate: Basic realm="WallyWorld"
</pre></div><div id="rfc.section.2.p.4"><p>where "WallyWorld" is the string assigned by the server to identify the protection space of the Request-URI. A proxy may respond with the same challenge using the Proxy-Authenticate header field.<a class="self" href="#rfc.section.2.p.4">&para;</a></p></div><div id="rfc.section.2.p.5"><p>To receive authorization, the client sends the userid and password, separated by a single colon (":") character, within a base64 <a href="#RFC2396" id="rfc.xref.RFC2396.1"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[7]</cite></a> encoded string in the credentials.<a class="self" href="#rfc.section.2.p.5">&para;</a></p></div><div id="rfc.figure.u.7"><pre class="inline"><span id="rfc.iref.b.1"></span><span id="rfc.iref.b.2"></span><span id="rfc.iref.u.1"></span><span id="rfc.iref.u.2"></span><span id="rfc.iref.p.1"></span>   basic-credentials = base64-user-pass
   base64-user-pass  = &lt;base64 <a href="#RFC2045" id="rfc.xref.RFC2045.1"><cite title="Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies">[4]</cite></a> encoding of user-pass,
                    except not limited to 76 char/line&gt;
   user-pass   = userid ":" password
   userid      = *&lt;TEXT excluding ":"&gt;
   password    = *TEXT
</pre></div><div id="rfc.section.2.p.6"><p>Userids might be case sensitive.<a class="self" href="#rfc.section.2.p.6">&para;</a></p></div><div id="rfc.section.2.p.7" class="avoidbreakafter"><p>If the user agent wishes to send the userid "Aladdin" and password "open sesame", it would use the following header field:<a class="self" href="#rfc.section.2.p.7">&para;</a></p></div><div id="rfc.figure.u.8"><pre class="text">   Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
</pre></div><div id="rfc.section.2.p.8"><p>A client <em class="bcp14">SHOULD</em> assume that all paths at or deeper than the depth of the last symbolic element in the path field of the Request-URI also are within the protection space specified by the Basic realm value of the current challenge. A client <em class="bcp14">MAY</em> preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another challenge from the server. Similarly, when a client sends a request to a proxy, it may reuse a userid and password in the Proxy-Authorization header field without receiving another challenge from the proxy server. See <a href="#security.considerations" title="Security Considerations">Section&nbsp;4</a> for security considerations associated with Basic authentication.<a class="self" href="#rfc.section.2.p.8">&para;</a></p></div></section><section id="n-digest-access-authentication-scheme"><h2 id="rfc.section.3"><a href="#rfc.section.3">3.</a>&nbsp;<a href="#n-digest-access-authentication-scheme">Digest Access Authentication Scheme</a></h2><section id="n-introduction"><h3 id="rfc.section.3.1"><a href="#rfc.section.3.1">3.1</a>&nbsp;<a href="#n-introduction">Introduction</a></h3><section id="n-purpose"><h4 id="rfc.section.3.1.1"><a href="#rfc.section.3.1.1">3.1.1</a>&nbsp;<a href="#n-purpose">Purpose</a></h4><div id="rfc.section.3.1.1.p.1"><p>The protocol referred to as "HTTP/1.0" includes the specification for a Basic Access Authentication scheme<a href="#RFC1945" id="rfc.xref.RFC1945.1"><cite title="Hypertext Transfer Protocol -- HTTP/1.0">[1]</cite></a>. That scheme is not considered to be a secure method of user authentication, as the user name and password are passed over the network in an unencrypted form. This section provides the specification for a scheme that does not send the password in cleartext, referred to as "Digest Access Authentication".<a class="self" href="#rfc.section.3.1.1.p.1">&para;</a></p></div><div id="rfc.section.3.1.1.p.2"><p>The Digest Access Authentication scheme is not intended to be a complete answer to the need for security in the World Wide Web. This scheme provides no encryption of message content. The intent is simply to create an access authentication method that avoids the most serious flaws of Basic authentication.<a class="self" href="#rfc.section.3.1.1.p.2">&para;</a></p></div></section><section id="n-overall-operation"><h4 id="rfc.section.3.1.2"><a href="#rfc.section.3.1.2">3.1.2</a>&nbsp;<a href="#n-overall-operation">Overall Operation</a></h4><div id="rfc.section.3.1.2.p.1"><p>Like Basic Access Authentication, the Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges using a nonce value. A valid response contains a checksum (by default, the MD5 checksum) of the username, the password, the given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear. Just as with the Basic scheme, the username and password must be prearranged in some fashion not addressed by this document.<a class="self" href="#rfc.section.3.1.2.p.1">&para;</a></p></div></section><section id="n-representation-of-digest-values"><h4 id="rfc.section.3.1.3"><a href="#rfc.section.3.1.3">3.1.3</a>&nbsp;<a href="#n-representation-of-digest-values">Representation of digest values</a></h4><div id="rfc.section.3.1.3.p.1"><p>An optional header allows the server to specify the algorithm used to create the checksum or digest. By default the MD5 algorithm is used and that is the only algorithm described in this document.<a class="self" href="#rfc.section.3.1.3.p.1">&para;</a></p></div><div id="rfc.section.3.1.3.p.2"><p>For the purposes of this document, an MD5 digest of 128 bits is represented as 32 ASCII printable characters. The bits in the 128 bit digest are converted from most significant to least significant bit, four bits at a time to their ASCII presentation as follows. Each four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef. That is, binary 0000 gets represented by the character '0', 0001, by '1', and so on up to the representation of 1111 as 'f'.<a class="self" href="#rfc.section.3.1.3.p.2">&para;</a></p></div></section><section id="n-limitations"><h4 id="rfc.section.3.1.4"><a href="#rfc.section.3.1.4">3.1.4</a>&nbsp;<a href="#n-limitations">Limitations</a></h4><div id="rfc.section.3.1.4.p.1"><p>The Digest authentication scheme described in this document suffers from many known limitations. It is intended as a replacement for Basic authentication and nothing more. It is a password-based system and (on the server side) suffers from all the same problems of any password system. In particular, no provision is made in this protocol for the initial secure arrangement between user and server to establish the user's password.<a class="self" href="#rfc.section.3.1.4.p.1">&para;</a></p></div><div id="rfc.section.3.1.4.p.2"><p>Users and implementors should be aware that this protocol is not as secure as Kerberos, and not as secure as any client-side private-key scheme. Nevertheless it is better than nothing, better than what is commonly used with telnet and ftp, and better than Basic authentication.<a class="self" href="#rfc.section.3.1.4.p.2">&para;</a></p></div></section></section><section id="specification.of.digest.headers"><h3 id="rfc.section.3.2"><a href="#rfc.section.3.2">3.2</a>&nbsp;<a href="#specification.of.digest.headers">Specification of Digest Headers</a></h3><div id="rfc.section.3.2.p.1"><p>The Digest Access Authentication scheme is conceptually similar to the Basic scheme. The formats of the modified WWW-Authenticate header line and the Authorization header line are specified below. In addition, a new header, Authentication-Info, is specified.<a class="self" href="#rfc.section.3.2.p.1">&para;</a></p></div><section id="the.www-authenticate.response.header"><h4 id="rfc.section.3.2.1"><a href="#rfc.section.3.2.1">3.2.1</a>&nbsp;<a href="#the.www-authenticate.response.header">The WWW-Authenticate Response Header</a></h4><div id="rfc.section.3.2.1.p.1" class="avoidbreakafter"><p>If a server receives a request for an access-protected object, and an acceptable Authorization header is not sent, the server responds with a "401 Unauthorized" status code, and a WWW-Authenticate header as per the framework defined above, which for the digest scheme is utilized as follows:<a class="self" href="#rfc.section.3.2.1.p.1">&para;</a></p></div><div id="rfc.figure.u.9"><pre class="inline"><span id="rfc.iref.c.5"></span><span id="rfc.iref.d.1"></span><span id="rfc.iref.d.2"></span><span id="rfc.iref.u.3"></span><span id="rfc.iref.n.1"></span><span id="rfc.iref.n.2"></span><span id="rfc.iref.o.1"></span><span id="rfc.iref.s.1"></span><span id="rfc.iref.a.3"></span><span id="rfc.iref.q.1"></span><span id="rfc.iref.q.2"></span>   challenge        =  "Digest" digest-challenge
  
   digest-challenge  = 1#( realm | [ domain ] | nonce |
                       [ opaque ] |[ stale ] | [ algorithm ] |
                       [ qop-options ] | [auth-param] )
  
  
   domain            = "domain" "=" &lt;"&gt; URI ( 1*SP URI ) &lt;"&gt;
   URI               = absoluteURI | abs_path
   nonce             = "nonce" "=" nonce-value
   nonce-value       = quoted-string
   opaque            = "opaque" "=" quoted-string
   stale             = "stale" "=" ( "true" | "false" )
   algorithm         = "algorithm" "=" ( "MD5" | "MD5-sess" |
                        token )
   qop-options       = "qop" "=" &lt;"&gt; 1#qop-value &lt;"&gt;
   qop-value         = "auth" | "auth-int" | token
</pre></div><div id="rfc.section.3.2.1.p.2" class="avoidbreakafter"><p>The meanings of the values of the directives used above are as follows:<a class="self" href="#rfc.section.3.2.1.p.2">&para;</a></p></div><div id="rfc.section.3.2.1.p.3"><p>realm <a class="self" href="#rfc.section.3.2.1.p.3">&para;</a></p><ul class="empty"><li>A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access. An example might be "registered_users@gotham.news.com".</li></ul></div><div id="rfc.section.3.2.1.p.4"><p>domain <a class="self" href="#rfc.section.3.2.1.p.4">&para;</a></p><ul class="empty"><li>A quoted, space-separated list of URIs, as specified in RFC XURI <a href="#RFC2396" id="rfc.xref.RFC2396.2"><cite title="Uniform Resource Identifiers (URI): Generic Syntax">[7]</cite></a>, that define the protection space. If a URI is an abs_path, it is relative to the canonical root URL (see <a href="#access.authentication.framework" title="Access Authentication Framework">Section&nbsp;1.2</a> above) of the server being accessed. An absoluteURI in this list may refer to a different server than the one being accessed. The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI that has a URI in this list as a prefix (after both have been made absolute) may be assumed to be in the same protection space. If this directive is omitted or its value is empty, the client should assume that the protection space consists of all URIs on the responding server. This directive is not meaningful in Proxy-Authenticate headers, for which the protection space is always the entire proxy; if present it should be ignored.</li></ul></div><div id="rfc.section.3.2.1.p.5"><p>nonce <a class="self" href="#rfc.section.3.2.1.p.5">&para;</a></p><ul class="empty"><li>A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data. Specifically, since the string is passed in the header lines as a quoted string, the double-quote character is not allowed.</li><li>The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce might, for example, be constructed as the base 64 encoding of</li><li><span id="rfc.figure.u.10"><pre class="text">   time-stamp H(time-stamp ":" ETag ":" private-key)
</pre></span></li><li>where time-stamp is a server-generated time or other non-repeating value, ETag is the value of the HTTP ETag header associated with the requested entity, and private-key is data known only to the server. With a nonce of this form a server would recalculate the hash portion after receiving the client authentication header and reject the request if it did not match the nonce from that header or if the time-stamp value is not recent enough. In this way the server can limit the time of the nonce's validity. The inclusion of the ETag prevents a replay request for an updated version of the resource. (Note: including the IP address of the client in the nonce would appear to offer the server the ability to limit the reuse of the nonce to the same client that originally got it. However, that would break proxy farms, where requests from a single user often go through different proxies in the farm. Also, IP address spoofing is not that hard.)</li><li>An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a time-stamp for GET requests. For more details on the issues involved see <a href="#security.considerations" title="Security Considerations">Section&nbsp;4</a> of this document.</li><li>The nonce is opaque to the client.</li></ul></div><div id="rfc.section.3.2.1.p.6"><p>opaque <a class="self" href="#rfc.section.3.2.1.p.6">&para;</a></p><ul class="empty"><li>A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data.</li></ul></div><div id="rfc.section.3.2.1.p.7"><p>stale <a class="self" href="#rfc.section.3.2.1.p.7">&para;</a></p><ul class="empty"><li>A flag, indicating that the previous request from the client was rejected because the nonce value was stale. If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response, without reprompting the user for a new username and password. The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce (indicating that the client knows the correct username/password). If stale is FALSE, or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.</li></ul></div><div id="rfc.section.3.2.1.p.8"><p>algorithm <a class="self" href="#rfc.section.3.2.1.p.8">&para;</a></p><ul class="empty"><li>A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be "MD5". If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).</li><li>In this document the string obtained by applying the digest algorithm to the data "data" with secret "secret" will be denoted by KD(secret, data), and the string obtained by applying the checksum algorithm to the data "data" will be denoted H(data). The notation unq(X) means the value of the quoted-string X without the surrounding quotes.</li><li>For the "MD5" and "MD5-sess" algorithms</li><li><span id="rfc.figure.u.11"><pre class="text">       H(data) = MD5(data)
</pre></span></li><li>and</li><li><span id="rfc.figure.u.12"><pre class="text">       KD(secret, data) = H(concat(secret, ":", data))
</pre></span></li><li>i.e., the digest is the MD5 of the secret concatenated with a colon concatenated with the data. The "MD5-sess" algorithm is intended to allow efficient 3rd party authentication servers; for the difference in usage, see the description in <a href="#A1" title="A1">Section&nbsp;3.2.2.2</a>.</li></ul></div><div id="rfc.section.3.2.1.p.9"><p>qop-options <a class="self" href="#rfc.section.3.2.1.p.9">&para;</a></p><ul class="empty"><li>This directive is optional, but is made so only for backward compatibility with RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.2"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>; it <em class="bcp14">SHOULD</em> be used by all implementations compliant with this version of the Digest scheme. If present, it is a quoted string of one or more tokens indicating the "quality of protection" values supported by the server. The value "auth" indicates authentication; the value "auth-int" indicates authentication with integrity protection; see the descriptions below for calculating the response directive value for the application of this choice. Unrecognized options <em class="bcp14">MUST</em> be ignored.</li></ul></div><div id="rfc.section.3.2.1.p.10"><p>auth-param <a class="self" href="#rfc.section.3.2.1.p.10">&para;</a></p><ul class="empty"><li>This directive allows for future extensions. Any unrecognized directive <em class="bcp14">MUST</em> be ignored.</li></ul></div></section><section id="the.authorization.request.header"><h4 id="rfc.section.3.2.2"><a href="#rfc.section.3.2.2">3.2.2</a>&nbsp;<a href="#the.authorization.request.header">The Authorization Request Header</a></h4><div id="rfc.section.3.2.2.p.1"><p>The client is expected to retry the request, passing an Authorization header line, which is defined according to the framework above, utilized as follows.<a class="self" href="#rfc.section.3.2.2.p.1">&para;</a></p></div><div id="rfc.figure.u.13"><pre class="inline"><span id="rfc.iref.c.6"></span><span id="rfc.iref.d.3"></span><span id="rfc.iref.u.4"></span><span id="rfc.iref.u.5"></span><span id="rfc.iref.d.4"></span><span id="rfc.iref.d.5"></span><span id="rfc.iref.m.1"></span><span id="rfc.iref.c.7"></span><span id="rfc.iref.c.8"></span><span id="rfc.iref.n.3"></span><span id="rfc.iref.n.4"></span><span id="rfc.iref.r.3"></span><span id="rfc.iref.r.4"></span><span id="rfc.iref.l.1"></span>    credentials      = "Digest" digest-response
    digest-response  = 1#( username | realm | nonce | digest-uri
                    | response | [ algorithm ] | [cnonce] |
                    [opaque] | [message-qop] |
                       [nonce-count]  | [auth-param] )
    
    username         = "username" "=" username-value
    username-value   = quoted-string
    digest-uri       = "uri" "=" digest-uri-value
    digest-uri-value = request-uri   ; As specified by HTTP/1.1
    message-qop      = "qop" "=" qop-value
    cnonce           = "cnonce" "=" cnonce-value
    cnonce-value     = nonce-value
    nonce-count      = "nc" "=" nc-value
    nc-value         = 8LHEX
    response         = "response" "=" request-digest
    request-digest = &lt;"&gt; 32LHEX &lt;"&gt;
    LHEX             =  "0" | "1" | "2" | "3" |
                       "4" | "5" | "6" | "7" |
                       "8" | "9" | "a" | "b" |
                       "c" | "d" | "e" | "f"
</pre></div><div id="rfc.section.3.2.2.p.2"><p>The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header for the entity being requested.<a class="self" href="#rfc.section.3.2.2.p.2">&para;</a></p></div><div id="rfc.section.3.2.2.p.3"><p>response <a class="self" href="#rfc.section.3.2.2.p.3">&para;</a></p><ul class="empty"><li>A string of 32 hex digits computed as defined below, which proves that the user knows a password</li></ul></div><div id="rfc.section.3.2.2.p.4"><p>username <a class="self" href="#rfc.section.3.2.2.p.4">&para;</a></p><ul class="empty"><li>The user's name in the specified realm.</li></ul></div><div id="rfc.section.3.2.2.p.5"><p>digest-uri <a class="self" href="#rfc.section.3.2.2.p.5">&para;</a></p><ul class="empty"><li>The URI from Request-URI of the Request-Line; duplicated here because proxies are allowed to change the Request-Line in transit.</li></ul></div><div id="rfc.section.3.2.2.p.6"><p>qop <a class="self" href="#rfc.section.3.2.2.p.6">&para;</a></p><ul class="empty"><li>Indicates what "quality of protection" the client has applied to the message. If present, its value <em class="bcp14">MUST</em> be one of the alternatives the server indicated it supports in the WWW-Authenticate header. These values affect the computation of the request-digest. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate. This directive is optional in order to preserve backward compatibility with a minimal implementation of RFC 2069 <a href="#RFC2069" id="rfc.xref.RFC2069.3"><cite title="An Extension to HTTP : Digest Access Authentication">[6]</cite></a>, but <em class="bcp14">SHOULD</em> be used if the server indicated that qop is supported by providing a qop directive in the WWW-Authenticate header field.</li></ul></div><div id="rfc.section.3.2.2.p.7"><p>cnonce <a class="self" href="#rfc.section.3.2.2.p.7">&para;</a></p><ul class="empty"><li>This <em class="bcp14">MUST</em> be specified if a qop directive is sent (see above), and <em class="bcp14">MUST NOT</em> be specified if the server did not send a qop directive in the WWW-Authenticate header field. The cnonce-value is an opaque quoted string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of the response-digest and request-digest values.</li></ul></div><div id="rfc.section.3.2.2.p.8"><p>nonce-count <a class="self" href="#rfc.section.3.2.2.p.8">&para;</a></p><ul class="empty"><li>This <em class="bcp14">MUST</em> be specified if a qop directive is sent (see above), and <em class="bcp14">MUST NOT</em> be specified if the server did not send a qop directive in the WWW-Authenticate header field. The nc-value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request. For example, in the first request sent in response to a given nonce value, the client sends "nc=00000001". The purpose of this directive is to allow the server to detect request replays by maintaining its own copy of this count - if the same nc-value is seen twice, then the request is a replay. See the description below of the construction of the request-digest value.</li></ul></div><div id="rfc.section.3.2.2.p.9"><p>auth-param <a class="self" href="#rfc.section.3.2.2.p.9">&para;</a></p><ul class="empty"><li>This directive allows for future extensions. Any unrecognized directive <em class="bcp14">MUST</em> be ignored.</li></ul></div><div id="rfc.section.3.2.2.p.10"><p>If a directive or its value is improper, or required directives are missing, the proper response is 400 Bad Request. If the request-digest is invalid, then a login failure should be logged, since repeated login failures from a single client may indicate an attacker attempting to guess passwords.<a class="self" href="#rfc.section.3.2.2.p.10">&para;</a></p></div><div id="rfc.section.3.2.2.p.11"><p>The definition of request-digest above indicates the encoding for its value. The following definitions show how the value is computed.<a class="self" href="#rfc.section.3.2.2.p.11">&para;</a></p></div><section id="request-digest"><h5 id="rfc.section.3.2.2.1"><a href="#rfc.section.3.2.2.1">3.2.2.1</a>&nbsp;<a href="#request-digest">Request-Digest</a></h5><div id="rfc.section.3.2.2.1.p.1" class="avoidbreakafter"><p>If the "qop" value is "auth" or "auth-int":<a class="self" href="#rfc.section.3.2.2.1.p.1">&para;</a></p></div><div id="rfc.figure.u.14"><pre class="inline">   request-digest  = &lt;"&gt; &lt; KD ( H(A1),     unq(nonce-value)
                                       ":" nc-value
                                       ":" unq(cnonce-value)
                                       ":" unq(qop-value)
                                       ":" H(A2)
                               ) &lt;"&gt;
</pre></div><div id="rfc.section.3.2.2.1.p.2" class="avoidbreakafter"><p>If the "qop" directive is not present (this construction is for compatibility with RFC 2069):<a class="self" href="#rfc.section.3.2.2.1.p.2">&para;</a></p></div><div id="rfc.figure.u.15"><pre class="inline">  request-digest  =
             &lt;"&gt; &lt; KD ( H(A1), unq(nonce-value) ":" H(A2) ) &gt;
&lt;"&gt;
</pre></div><div id="rfc.section.3.2.2.1.p.3"><p>See below for the definitions for A1 and A2.<a class="self" href="#rfc.section.3.2.2.1.p.3">&para;</a></p></div></section><section id="A1"><h5 id="rfc.section.3.2.2.2"><a href="#rfc.section.3.2.2.2">3.2.2.2</a>&nbsp;<a href="#A1">A1</a></h5><div id="rfc.section.3.2.2.2.p.1" class="avoidbreakafter"><p>If the "algorithm" directive's value is "MD5" or is unspecified, then A1 is:<a class="self" href="#rfc.section.3.2.2.2.p.1">&para;</a></p></div><div id="rfc.figure.u.16"><pre class="inline">   A1       = unq(username-value) ":" unq(realm-value) ":" passwd
</pre></div><div id="rfc.section.3.2.2.2.p.2"><p>where<a class="self" href="#rfc.section.3.2.2.2.p.2">&para;</a></p></div><div id="rfc.figure.u.17"><pre class="inline">   passwd   = &lt; user's password &gt;
</pre></div><div id="rfc.section.3.2.2.2.p.3" class="avoidbreakafter"><p>If the "algorithm" directive's value is "MD5-sess", then A1 is calculated only once - on the first request by the client following receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, and the first client nonce value to construct A1 as follows:<a class="self" href="#rfc.section.3.2.2.2.p.3">&para;</a></p></div><div id="rfc.figure.u.18"><pre class="inline">   A1       = H( unq(username-value) ":" unq(realm-value)
                  ":" passwd )
                  ":" unq(nonce-value) ":" unq(cnonce-value)
</pre></div><div id="rfc.section.3.2.2.2.p.4"><p>This creates a 'session key' for the authentication of subsequent requests and responses which is different for each "authentication session", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication session in <a href="#digest.operation" title="Digest Operation">Section&nbsp;3.3</a>) Because the server need only use the hash of the user credentials in order to create the A1 value, this construction could be used in conjunction with a third party authentication service so that the web server would not need the actual password value. The specification of such a protocol is beyond the scope of this specification.<a class="self" href="#rfc.section.3.2.2.2.p.4">&para;</a></p></div></section><section id="n-a2"><h5 id="rfc.section.3.2.2.3"><a href="#rfc.section.3.2.2.3">3.2.2.3</a>&nbsp;<a href="#n-a2">A2</a></h5><div id="rfc.section.3.2.2.3.p.1" class="avoidbreakafter"><p>If the "qop" directive's value is "auth" or is unspecified, then A2 is:<a class="self" href="#rfc.section.3.2.2.3.p.1">&para;</a></p></div><div id="rfc.figure.u.19"><pre class="inline">   A2       = Method ":" digest-uri-value
</pre></div><div id="rfc.section.3.2.2.3.p.2" class="avoidbreakafter"><p>If the "qop" value is "auth-int", then A2 is:<a class="self" href="#rfc.section.3.2.2.3.p.2">&para;</a></p></div><div id="rfc.figure.u.20"><pre class="inline">   A2       = Method ":" digest-uri-value ":" H(entity-body)
</pre></div></section><section id="n-directive-values-and-quoted-string"><h5 id="rfc.section.3.2.2.4"><a href="#rfc.section.3.2.2.4">3.2.2.4</a>&nbsp;<a href="#n-directive-values-and-quoted-string">Directive values and quoted-string</a></h5><div id="rfc.section.3.2.2.4.p.1"><p>Note that the value of many of the directives, such as "username-value", are defined as a "quoted-string". However, the "unq" notation indicates that surrounding quotation marks are removed in forming the string A1. Thus if the Authorization header includes the fields<a class="self" href="#rfc.section.3.2.2.4.p.1">&para;</a></p></div><div id="rfc.figure.u.21"><pre class="text">  username="Mufasa", realm=myhost@testrealm.com
</pre></div><div id="rfc.section.3.2.2.4.p.2"><p>and the user Mufasa has password "Circle Of Life" then H(A1) would be H(Mufasa:myhost@testrealm.com:Circle Of Life) with no quotation marks in the digested string.<a class="self" href="#rfc.section.3.2.2.4.p.2">&para;</a></p></div><div id="rfc.section.3.2.2.4.p.3"><p>No white space is allowed in any of the strings to which the digest function H() is applied unless that white space exists in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated above must be<a class="self" href="#rfc.section.3.2.2.4.p.3">&para;</a></p></div><div id="rfc.figure.u.22"><pre class="text">     Mufasa:myhost@testrealm.com:Circle Of Life
</pre></div><div id="rfc.section.3.2.2.4.p.4"><p>with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise, the other strings digested by H() must not have white space on either side of the colons which delimit their fields unless that white space was in the quoted strings or entity body being digested.<a class="self" href="#rfc.section.3.2.2.4.p.4">&para;</a></p></div><div id="rfc.section.3.2.2.4.p.5"><p>Also note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body - it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded headers in each part of any multipart content-type.<a class="self" href="#rfc.section.3.2.2.4.p.5">&para;</a></p></div></section><section id="n-various-considerations"><h5 id="rfc.section.3.2.2.5"><a href="#rfc.section.3.2.2.5">3.2.2.5</a>&nbsp;<a href="#n-various-considerations">Various considerations</a></h5><div id="rfc.section.3.2.2.5.p.1"><p>The "Method" value is the HTTP request method as specified in section <a href="https://tools.ietf.org/html/rfc2616#section-5.1.1" title="Method" id="rfc.xref.RFC2616.9">5.1.1</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.10"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. The "request-uri" value is the Request-URI from the request line as specified in section <a href="https://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.11">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.12"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>. This may be "*", an "absoluteURL" or an "abs_path" as specified in section <a href="https://tools.ietf.org/html/rfc2616#section-5.1.2" title="Request-URI" id="rfc.xref.RFC2616.13">5.1.2</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.14"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>, but it <em class="bcp14">MUST</em> agree with the Request-URI. In particular, it <em class="bcp14">MUST</em> be an "absoluteURL" if the Request-URI is an "absoluteURL". The "cnonce-value" is an optional client-chosen value whose purpose is to foil chosen plaintext attacks.<a class="self" href="#rfc.section.3.2.2.5.p.1">&para;</a></p></div><div id="rfc.section.3.2.2.5.p.2"><p>The authenticating server must assure that the resource designated by the "uri" directive is the same as the resource specified in the Request-Line; if they are not, the server <em class="bcp14">SHOULD</em> return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would not result in the same digest as that calculated by the client.<a class="self" href="#rfc.section.3.2.2.5.p.2">&para;</a></p></div><div id="rfc.section.3.2.2.5.p.3"><p>Implementers should be aware of how authenticated transactions interact with shared caches. The HTTP/1.1 protocol specifies that when a shared cache (see section <a href="https://tools.ietf.org/html/rfc2616#section-13.7" title="Shared and Non-Shared Caches" id="rfc.xref.RFC2616.15">13.7</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.16"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) has received a request containing an Authorization header and a response from relaying that request, it <em class="bcp14">MUST NOT</em> return that response as a reply to any other request, unless one of two Cache-Control (see section <a href="https://tools.ietf.org/html/rfc2616#section-14.9" title="Cache-Control" id="rfc.xref.RFC2616.17">14.9</a> of <a href="#RFC2616" id="rfc.xref.RFC2616.18"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a>) directives was present in the response. If the original response included the "must-revalidate" Cache-Control directive, the cache <em class="bcp14">MAY</em> use the entity of that response in replying to a subsequent request, but <em class="bcp14">MUST</em> first revalidate it with the origin server, using the request headers from the new request to allow the origin server to authenticate the new request. Alternatively, if the original response included the "public" Cache-Control directive, the response entity <em class="bcp14">MAY</em> be returned in reply to any subsequent request.<a class="self" href="#rfc.section.3.2.2.5.p.3">&para;</a></p></div></section></section><section id="n-the-authentication-info-header"><h4 id="rfc.section.3.2.3"><a href="#rfc.section.3.2.3">3.2.3</a>&nbsp;<a href="#n-the-authentication-info-header">The Authentication-Info Header</a></h4><div id="rfc.section.3.2.3.p.1"><p>The Authentication-Info header is used by the server to communicate some information regarding the successful authentication in the response.<a class="self" href="#rfc.section.3.2.3.p.1">&para;</a></p></div><div id="rfc.figure.u.23"><pre class="inline"><span id="rfc.iref.a.4"></span><span id="rfc.iref.a.5"></span><span id="rfc.iref.n.5"></span><span id="rfc.iref.r.5"></span><span id="rfc.iref.r.6"></span>     AuthenticationInfo = "Authentication-Info" ":" auth-info
     auth-info          = 1#(nextnonce | [ message-qop ]
                            | [ response-auth ] | [ cnonce ]
                            | [nonce-count] )
     nextnonce          = "nextnonce" "=" nonce-value
     response-auth      = "rspauth" "=" response-digest
     response-digest    = &lt;"&gt; *LHEX &lt;"&gt;
</pre></div><div id="rfc.section.3.2.3.p.2"><p>The value of the nextnonce directive is the nonce the server wishes the client to use for a future authentication response. The server may send the Authentication-Info header with a nextnonce field as a means of implementing one-time or otherwise changing nonces. If the nextnonce field is present the client <em class="bcp14">SHOULD</em> use it when constructing the Authorization header for its next request. Failure of the client to do so may result in a request to re-authenticate from the server with the "stale=TRUE".<a class="self" href="#rfc.section.3.2.3.p.2">&para;</a></p></div><div id="rfc.section.3.2.3.p.3"><ul class="empty"><li>Server implementations should carefully consider the performance implications of the use of this mechanism; pipelined requests will not be possible if every response includes a nextnonce directive that must be used on the next request received by the server. Consideration should be given to the performance vs. security tradeoffs of allowing an old nonce value to be used for a limited time to permit request pipelining. Use of the nonce-count can retain most of the security advantages of a new server nonce without the deleterious affects on pipelining.</li></ul></div><div id="rfc.section.3.2.3.p.4"><p>message-qop<a class="self" href="#rfc.section.3.2.3.p.4">&para;</a></p></div><div id="rfc.section.3.2.3.p.5"><ul class="empty"><li>Indicates the "quality of protection" options applied to the response by the server. The value "auth" indicates authentication; the value "auth-int" indicates authentication with integrity protection. The server <em class="bcp14">SHOULD</em> use the same value for the message-qop directive in the response as was sent by the client in the corresponding request.</li></ul></div><div id="rfc.section.3.2.3.p.6"><p>The optional response digest in the "response-auth" directive supports mutual authentication -- the server proves that it knows the user's secret, and with qop=auth-int also provides limited integrity protection of the response. The "response-digest" value is calculated as for the "request-digest" in the Authorization header, except that if "qop=auth" or is not specified in the Authorization header for the request, A2 is<a class="self" href="#rfc.section.3.2.3.p.6">&para;</a></p></div><div id="rfc.figure.u.24"><pre class="inline">   A2       = ":" digest-uri-value
</pre></div><div id="rfc.section.3.2.3.p.7"><p>and if "qop=auth-int", then A2 is<a class="self" href="#rfc.section.3.2.3.p.7">&para;</a></p></div><div id="rfc.figure.u.25"><pre class="inline">   A2       = ":" digest-uri-value ":" H(entity-body)
</pre></div><div id="rfc.section.3.2.3.p.8"><p>where "digest-uri-value" is the value of the "uri" directive on the Authorization header in the request. The "cnonce-value" and "nc-value" <em class="bcp14">MUST</em> be the ones for the client request to which this message is the response. The "response-auth", "cnonce", and "nonce-count" directives <em class="bcp14">MUST</em> BE present if "qop=auth" or "qop=auth-int" is specified.<a class="self" href="#rfc.section.3.2.3.p.8">&para;</a></p></div><div id="rfc.section.3.2.3.p.9"><p>The Authentication-Info header is allowed in the trailer of an HTTP message transferred via chunked transfer-coding.<a class="self" href="#rfc.section.3.2.3.p.9">&para;</a></p></div></section></section><section id="digest.operation"><h3 id="rfc.section.3.3"><a href="#rfc.section.3.3">3.3</a>&nbsp;<a href="#digest.operation">Digest Operation</a></h3><div id="rfc.section.3.3.p.1"><p>Upon receiving the Authorization header, the server may check its validity by looking up the password that corresponds to the submitted username. Then, the server must perform the same digest operation (e.g., MD5) performed by the client, and compare the result to the given request-digest value.<a class="self" href="#rfc.section.3.3.p.1">&para;</a></p></div><div id="rfc.section.3.3.p.2"><p>Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the server, the validity of an Authorization header may be verified.<a class="self" href="#rfc.section.3.3.p.2">&para;</a></p></div><div id="rfc.section.3.3.p.3"><p>The client response to a WWW-Authenticate challenge for a protection space starts an authentication session with that protection space. The authentication session lasts until the client receives another WWW-Authenticate challenge from any server in the protection space. A client should remember the username, password, nonce, nonce count and opaque values associated with an authentication session to use to construct the Authorization header in future requests within that protection space. The Authorization header may be included preemptively; doing so improves server efficiency and avoids extra round trips for authentication challenges. The server may choose to accept the old Authorization header information, even though the nonce value included might not be fresh. Alternatively, the server may return a 401 response with a new nonce value, causing the client to retry the request; by specifying stale=TRUE with this response, the server tells the client to retry with the new nonce, but without prompting for a new username and password.<a class="self" href="#rfc.section.3.3.p.3">&para;</a></p></div><div id="rfc.section.3.3.p.4"><p>Because the client is required to return the value of the opaque directive given to it by the server for the duration of a session, the opaque data may be used to transport authentication session state information. (Note that any such use can also be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for authenticating content that actually sits on another server. It would achieve this by having the first 401 response include a domain directive whose value includes a URI on the second server, and an opaque directive whose value contains the state information. The client will retry the request, at which time the server might respond with a 301/302 redirection, pointing to the URI on the second server. The client will follow the redirection, and pass an Authorization header , including the &lt;opaque&gt; data.<a class="self" href="#rfc.section.3.3.p.4">&para;</a></p></div><div id="rfc.section.3.3.p.5"><p>As with the basic scheme, proxies must be completely transparent in the Digest access authentication scheme. That is, they must forward the WWW-Authenticate, Authentication-Info and Authorization headers untouched. If a proxy wants to authenticate a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization headers described in <a href="#proxy-authentication.and.proxy-authorization" title="Proxy-Authentication and Proxy-Authorization">Section&nbsp;3.6</a> below.<a class="self" href="#rfc.section.3.3.p.5">&para;</a></p></div></section><section id="n-security-protocol-negotiation"><h3 id="rfc.section.3.4"><a href="#rfc.section.3.4">3.4</a>&nbsp;<a href="#n-security-protocol-negotiation">Security Protocol Negotiation</a></h3><div id="rfc.section.3.4.p.1"><p>It is useful for a server to be able to know which security schemes a client is capable of handling.<a class="self" href="#rfc.section.3.4.p.1">&para;</a></p></div><div id="rfc.section.3.4.p.2"><p>It is possible that a server may want to require Digest as its authentication method, even if the server does not know that the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot handle.<a class="self" href="#rfc.section.3.4.p.2">&para;</a></p></div></section><section id="specification.of.digest.headers.example"><h3 id="rfc.section.3.5"><a href="#rfc.section.3.5">3.5</a>&nbsp;<a href="#specification.of.digest.headers.example">Example</a></h3><div id="rfc.section.3.5.p.1"><p>The following example assumes that an access-protected document is being requested from the server via a GET request. The URI of the document is "http://www.nowhere.org/dir/index.html". Both client and server know that the username for this document is "Mufasa", and the password is "Circle Of Life" (with one space between each of the three words).<a class="self" href="#rfc.section.3.5.p.1">&para;</a></p></div><div id="rfc.section.3.5.p.2" class="avoidbreakafter"><p>The first time the client requests the document, no Authorization header is sent, so the server responds with:<a class="self" href="#rfc.section.3.5.p.2">&para;</a></p></div><div id="rfc.figure.u.26"><pre class="text">      HTTP/1.1 401 Unauthorized
      WWW-Authenticate: Digest
              realm="testrealm@host.com",
              qop="auth,auth-int",
              nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
              opaque="5ccc069c403ebaf9f0171e9517f40e41"
</pre></div><div id="rfc.section.3.5.p.3" class="avoidbreakafter"><p>The client may prompt the user for the username and password, after which it will respond with a new request, including the following Authorization header:<a class="self" href="#rfc.section.3.5.p.3">&para;</a></p></div><div id="rfc.figure.u.27"><pre class="text">      Authorization: Digest username="Mufasa",
              realm="testrealm@host.com",
              nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
              uri="/dir/index.html",
              qop=auth,
              nc=00000001,
              cnonce="0a4f113b",
              response="6629fae49393a05397450978507c4ef1",
              opaque="5ccc069c403ebaf9f0171e9517f40e41"
</pre></div></section><section id="proxy-authentication.and.proxy-authorization"><h3 id="rfc.section.3.6"><a href="#rfc.section.3.6">3.6</a>&nbsp;<a href="#proxy-authentication.and.proxy-authorization">Proxy-Authentication and Proxy-Authorization</a></h3><div id="rfc.section.3.6.p.1"><p>The digest authentication scheme may also be used for authenticating users to proxies, proxies to proxies, or proxies to origin servers by use of the Proxy-Authenticate and Proxy-Authorization headers. These headers are instances of the Proxy-Authenticate and Proxy-Authorization headers specified in sections <a href="https://tools.ietf.org/html/rfc2616#section-10.33" id="rfc.xref.RFC2616.19">10.33</a> and <a href="https://tools.ietf.org/html/rfc2616#section-10.34" id="rfc.xref.RFC2616.20">10.34</a> of the HTTP/1.1 specification <a href="#RFC2616" id="rfc.xref.RFC2616.21"><cite title="Hypertext Transfer Protocol -- HTTP/1.1">[2]</cite></a> and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar to those already described. Upon receiving a request which requires authentication, the proxy/server must issue the "407 Proxy Authentication Required" response with a "Proxy-Authenticate" header. The digest-challenge used in the Proxy-Authenticate header is the same as that for the WWW-Authenticate header as defined above in <a href="#the.www-authenticate.response.header" title="The WWW-Authenticate Response Header">Section&nbsp;3.2.1</a>.<a class="self" href="#rfc.section.3.6.p.1">&para;</a></p></div><div id="rfc.section.3.6.p.2"><p>The client/proxy must then re-issue the request with a Proxy-Authorization header, with directives as specified for the Authorization header in <a href="#the.authorization.request.header" title="The Authorization Request Header">Section&nbsp;3.2.2</a> above.<a class="self" href="#rfc.section.3.6.p.2">&para;</a></p></div><div id="rfc.section.3.6.p.3"><p>On subsequent responses, the server sends Proxy-Authentication-Info with directives the same as those for the Authentication-Info header field.<a class="self" href="#rfc.section.3.6.p.3">&para;</a></p></div><div id="rfc.section.3.6.p.4"><p>Note that in principle a client could be asked to authenticate itself to both a proxy and an end-server, but never in the same response.<a class="self" href="#rfc.section.3.6.p.4">&para;</a></p></div></section></section><section id="security.considerations"><h2 id="rfc.section.4"><a href="#rfc.section.4">4.</a>&nbsp;<a href="#security.considerations">Security Considerations</a></h2><section id="n-authentication-of-clients-using-basic-authentication"><h3 id="rfc.section.4.1"><a href="#rfc.section.4.1">4.1</a>&nbsp;<a href="#n-authentication-of-clients-using-basic-authentication">Authentication of Clients using Basic Authentication</a></h3><div id="rfc.section.4.1.p.1"><p>The Basic authentication scheme is not a secure method of user authentication, nor does it in any way protect the entity, which is transmitted in cleartext across the physical network used as the carrier. HTTP does not prevent additional authentication schemes and encryption mechanisms from being employed to increase security or the addition of enhancements (such as schemes to use one-time passwords) to Basic authentication.<a class="self" href="#rfc.section.4.1.p.1">&para;</a></p></div><div id="rfc.section.4.1.p.2"><p>The most serious flaw in Basic authentication is that it results in the essentially cleartext transmission of the user's password over the physical network. It is this problem which Digest Authentication attempts to address.<a class="self" href="#rfc.section.4.1.p.2">&para;</a></p></div><div id="rfc.section.4.1.p.3"><p>Because Basic authentication involves the cleartext transmission of passwords it <em class="bcp14">SHOULD NOT</em> be used (without enhancements) to protect sensitive or valuable information.<a class="self" href="#rfc.section.4.1.p.3">&para;</a></p></div><div id="rfc.section.4.1.p.4"><p>A common use of Basic authentication is for identification purposes -- requiring the user to provide a user name and password as a means of identification, for example, for purposes of gathering accurate usage statistics on a server. When used in this way it is tempting to think that there is no danger in its use if illicit access to the protected documents is not a major concern. This is only correct if the server issues both user name and password to the users and in particular does not allow the user to choose his or her own password. The danger arises because naive users frequently reuse a single password to avoid the task of maintaining multiple passwords.<a class="self" href="#rfc.section.4.1.p.4">&para;</a></p></div><div id="rfc.section.4.1.p.5"><p>If a server permits users to select their own passwords, then the threat is not only unauthorized access to documents on the server but also unauthorized access to any other resources on other systems that the user protects with the same password. Furthermore, in the server's password database, many of the passwords may also be users' passwords for other sites. The owner or administrator of such a system could therefore expose all users of the system to the risk of unauthorized access to all those sites if this information is not maintained in a secure fashion.<a class="self" href="#rfc.section.4.1.p.5">&para;</a></p></div><div id="rfc.section.4.1.p.6"><p>Basic Authentication is also vulnerable to spoofing by counterfeit servers. If a user can be led to believe that he is connecting to a host containing information protected by Basic authentication when, in fact, he is connecting to a hostile server or gateway, then the attacker can request a password, store it for later use, and feign an error. This type of attack is not possible with Digest Authentication. Server implementers <em class="bcp14">SHOULD</em> guard against the possibility of this sort of counterfeiting by gateways or CGI scripts. In particular it is very dangerous for a server to simply turn over a connection to a gateway. That gateway can then use the persistent connection mechanism to engage in multiple transactions with the client while impersonating the original server in a way that is not detectable by the client.<a class="self" href="#rfc.section.4.1.p.6">&para;</a></p></div></section><section id="n-authentication-of-clients-using-digest-authentication"><h3 id="rfc.section.4.2"><a href="#rfc.section.4.2">4.2</a>&nbsp;<a href="#n-authentication-of-clients-using-digest-authentication">Authentication of Clients using Digest Authentication</a></h3><div id="rfc.section.4.2.p.1"><p>Digest Authentication does not provide a strong authentication mechanism, when compared to public key based mechanisms, for example. However, it is significantly stronger than (e.g.) CRAM-MD5, which has been proposed for use with LDAP <a href="#ref10" id="rfc.xref.ref10.1"><cite title="Authentication Methods for LDAP">[10]</cite></a>, POP and IMAP (see RFC 2195 <a href="#RFC2195" id="rfc.xref.RFC2195.1"><cite title="IMAP/POP AUTHorize Extension for Simple Challenge/Response">[9]</cite></a>). It is intended to replace the much weaker and even more dangerous Basic mechanism.<a class="self" href="#rfc.section.4.2.p.1">&para;</a></p></div><div id="rfc.section.4.2.p.2"><p>Digest Authentication offers no confidentiality protection beyond protecting the actual password. All of the rest of the request and response are available to an eavesdropper.<a class="self" href="#rfc.section.4.2.p.2">&para;</a></p></div><div id="rfc.section.4.2.p.3"><p>Digest Authentication offers only limited integrity protection for the messages in either direction. If qop=auth-int mechanism is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response directive values (see <a href="#specification.of.digest.headers" title="Specification of Digest Headers">Section&nbsp;3.2</a> above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.<a class="self" href="#rfc.section.4.2.p.3">&para;</a></p></div><div id="rfc.section.4.2.p.4"><p>Many needs for secure HTTP transactions cannot be met by Digest Authentication. For those needs TLS or SHTTP are more appropriate protocols. In particular Digest authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless many functions remain for which Digest authentication is both useful and appropriate. Any service in present use that uses Basic should be switched to Digest as soon as practical.<a class="self" href="#rfc.section.4.2.p.4">&para;</a></p></div></section><section id="n-limited-use-nonce-values"><h3 id="rfc.section.4.3"><a href="#rfc.section.4.3">4.3</a>&nbsp;<a href="#n-limited-use-nonce-values">Limited Use Nonce Values</a></h3><div id="rfc.section.4.3.p.1"><p>The Digest scheme uses a server-specified nonce to seed the generation of the request-digest value (as specified in <a href="#request-digest" title="Request-Digest">Section&nbsp;3.2.2.1</a> above). As shown in the example nonce in <a href="#the.www-authenticate.response.header" title="The WWW-Authenticate Response Header">Section&nbsp;3.2.1</a>, the server is free to construct the nonce such that it may only be used from a particular client, for a particular resource, for a limited period of time or number of uses, or any other restrictions. Doing so strengthens the protection provided against, for example, replay attacks (see <a href="#replay.attacks" title="Replay Attacks">4.5</a>). However, it should be noted that the method chosen for generating and checking the nonce also has performance and resource implications. For example, a server may choose to allow each nonce value to be used only once by maintaining a record of whether or not each recently issued nonce has been returned and sending a next-nonce directive in the Authentication-Info header field of every response. This protects against even an immediate replay attack, but has a high cost checking nonce values, and perhaps more important will cause authentication failures for any pipelined requests (presumably returning a stale nonce indication). Similarly, incorporating a request-specific element such as the Etag value for a resource limits the use of the nonce to that version of the resource and also defeats pipelining. Thus it may be useful to do so for methods with side effects but have unacceptable performance for those that do not.<a class="self" href="#rfc.section.4.3.p.1">&para;</a></p></div></section><section id="n-comparison-of-digest-with-basic-authentication"><h3 id="rfc.section.4.4"><a href="#rfc.section.4.4">4.4</a>&nbsp;<a href="#n-comparison-of-digest-with-basic-authentication">Comparison of Digest with Basic Authentication</a></h3><div id="rfc.section.4.4.p.1"><p>Both Digest and Basic Authentication are very much on the weak end of the security strength spectrum. But a comparison between the two points out the utility, even necessity, of replacing Basic by Digest.<a class="self" href="#rfc.section.4.4.p.1">&para;</a></p></div><div id="rfc.section.4.4.p.2"><p>The greatest threat to the type of transactions for which these protocols are used is network snooping. This kind of transaction might involve, for example, online access to a database whose use is restricted to paying subscribers. With Basic authentication an eavesdropper can obtain the password of the user. This not only permits him to access anything in the database, but, often worse, will permit access to anything else the user protects with the same password.<a class="self" href="#rfc.section.4.4.p.2">&para;</a></p></div><div id="rfc.section.4.4.p.3"><p>By contrast, with Digest Authentication the eavesdropper only gets access to the transaction in question and not to the user's password. The information gained by the eavesdropper would permit a replay attack, but only with a request for the same document, and even that may be limited by the server's choice of nonce.<a class="self" href="#rfc.section.4.4.p.3">&para;</a></p></div></section><section id="replay.attacks"><h3 id="rfc.section.4.5"><a href="#rfc.section.4.5">4.5</a>&nbsp;<a href="#replay.attacks">Replay Attacks</a></h3><div id="rfc.section.4.5.p.1"><p>A replay attack against Digest authentication would usually be pointless for a simple GET request since an eavesdropper would already have seen the only document he could obtain with a replay. This is because the URI of the requested document is digested in the client request and the server will only deliver that document. By contrast under Basic Authentication once the eavesdropper has the user's password, any document protected by that password is open to him.<a class="self" href="#rfc.section.4.5.p.1">&para;</a></p></div><div id="rfc.section.4.5.p.2"><p>Thus, for some purposes, it is necessary to protect against replay attacks. A good Digest implementation can do this in various ways. The server created "nonce" value is implementation dependent, but if it contains a digest of the client IP, a time-stamp, the resource ETag, and a private server key (as recommended above) then a replay attack is not simple. An attacker must convince the server that the request is coming from a false IP address and must cause the server to deliver the document to an IP address different from the address to which it believes it is sending the document. An attack can only succeed in the period before the time-stamp expires. Digesting the client IP and time-stamp in the nonce permits an implementation which does not maintain state between transactions.<a class="self" href="#rfc.section.4.5.p.2">&para;</a></p></div><div id="rfc.section.4.5.p.3"><p>For applications where no possibility of replay attack can be tolerated the server can use one-time nonce values which will not be honored for a second use. This requires the overhead of the server remembering which nonce values have been used until the nonce time-stamp (and hence the digest built with it) has expired, but it effectively protects against replay attacks.<a class="self" href="#rfc.section.4.5.p.3">&para;</a></p></div><div id="rfc.section.4.5.p.4"><p>An implementation must give special attention to the possibility of replay attacks with POST and PUT requests. Unless the server employs one-time or otherwise limited-use nonces and/or insists on the use of the integrity protection of qop=auth-int, an attacker could replay valid credentials from a successful request with counterfeit form data or other message body. Even with the use of integrity protection most metadata in header fields is not protected. Proper nonce generation and checking provides some protection against replay of previously used valid credentials, but see 4.8.<a class="self" href="#rfc.section.4.5.p.4">&para;</a></p></div></section><section id="n-weakness-created-by-multiple-authentication-schemes"><h3 id="rfc.section.4.6"><a href="#rfc.section.4.6">4.6</a>&nbsp;<a href="#n-weakness-created-by-multiple-authentication-schemes">Weakness Created by Multiple Authentication Schemes</a></h3><div id="rfc.section.4.6.p.1"><p>An HTTP/1.1 server may return multiple challenges with a 401 (Authenticate) response, and each challenge may use a different auth-scheme. A user agent <em class="bcp14">MUST</em> choose to use the strongest auth-scheme it understands and request credentials from the user based upon that challenge.<a class="self" href="#rfc.section.4.6.p.1">&para;</a></p></div><div id="rfc.section.4.6.p.2"><ul class="empty"><li>Note that many browsers will only recognize Basic and will require that it be the first auth-scheme presented. Servers should only include Basic if it is minimally acceptable.</li></ul></div><div id="rfc.section.4.6.p.3"><p>When the server offers choices of authentication schemes using the WWW-Authenticate header, the strength of the resulting authentication is only as good as that of the of the weakest of the authentication schemes. See <a href="#man.in.the.middle" title="Man in the Middle">Section&nbsp;4.8</a> below for discussion of particular attack scenarios that exploit multiple authentication schemes.<a class="self" href="#rfc.section.4.6.p.3">&para;</a></p></div></section><section id="n-online-dictionary-attacks"><h3 id="rfc.section.4.7"><a href="#rfc.section.4.7">4.7</a>&nbsp;<a href="#n-online-dictionary-attacks">Online dictionary attacks</a></h3><div id="rfc.section.4.7.p.1"><p>If the attacker can eavesdrop, then it can test any overheard nonce/response pairs against a list of common words. Such a list is usually much smaller than the total number of possible passwords. The cost of computing the response for each password on the list is paid once for each challenge.<a class="self" href="#rfc.section.4.7.p.1">&para;</a></p></div><div id="rfc.section.4.7.p.2"><p>The server can mitigate this attack by not allowing users to select passwords that are in a dictionary.<a class="self" href="#rfc.section.4.7.p.2">&para;</a></p></div></section><section id="man.in.the.middle"><h3 id="rfc.section.4.8"><a href="#rfc.section.4.8">4.8</a>&nbsp;<a href="#man.in.the.middle">Man in the Middle</a></h3><div id="rfc.section.4.8.p.1"><p>Both Basic and Digest authentication are vulnerable to "man in the middle" (MITM) attacks, for example, from a hostile or compromised proxy. Clearly, this would present all the problems of eavesdropping. But it also offers some additional opportunities to the attacker.<a class="self" href="#rfc.section.4.8.p.1">&para;</a></p></div><div id="rfc.section.4.8.p.2"><p>A possible man-in-the-middle attack would be to add a weak authentication scheme to the set of choices, hoping that the client will use one that exposes the user's credentials (e.g. password). For this reason, the client should always use the strongest scheme that it understands from the choices offered.<a class="self" href="#rfc.section.4.8.p.2">&para;</a></p></div><div id="rfc.section.4.8.p.3"><p>An even better MITM attack would be to remove all offered choices, replacing them with a challenge that requests only Basic authentication, then uses the cleartext credentials from the Basic authentication to authenticate to the origin server using the stronger scheme it requested. A particularly insidious way to mount such a MITM attack would be to offer a "free" proxy caching service to gullible users.<a class="self" href="#rfc.section.4.8.p.3">&para;</a></p></div><div id="rfc.section.4.8.p.4"><p>User agents should consider measures such as presenting a visual indication at the time of the credentials request of what authentication scheme is to be used, or remembering the strongest authentication scheme ever requested by a server and produce a warning message before using a weaker one. It might also be a good idea for the user agent to be configured to demand Digest authentication in general, or from specific sites.<a class="self" href="#rfc.section.4.8.p.4">&para;</a></p></div><div id="rfc.section.4.8.p.5"><p>Or, a hostile proxy might spoof the client into making a request the attacker wanted rather than one the client wanted. Of course, this is still much harder than a comparable attack against Basic Authentication.<a class="self" href="#rfc.section.4.8.p.5">&para;</a></p></div></section><section id="n-chosen-plaintext-attacks"><h3 id="rfc.section.4.9"><a href="#rfc.section.4.9">4.9</a>&nbsp;<a href="#n-chosen-plaintext-attacks">Chosen plaintext attacks</a></h3><div id="rfc.section.4.9.p.1"><p>With Digest authentication, a MITM or a malicious server can arbitrarily choose the nonce that the client will use to compute the response. This is called a "chosen plaintext" attack. The ability to choose the nonce is known to make cryptanalysis much easier <a href="#ref8" id="rfc.xref.ref8.1"><cite title="Message Authentication with MD5">[8]</cite></a>.<a class="self" href="#rfc.section.4.9.p.1">&para;</a></p></div><div id="rfc.section.4.9.p.2"><p>However, no way to analyze the MD5 one-way function used by Digest using chosen plaintext is currently known.<a class="self" href="#rfc.section.4.9.p.2">&para;</a></p></div><div id="rfc.section.4.9.p.3"><p>The countermeasure against this attack is for clients to be configured to require the use of the optional "cnonce" directive; this allows the client to vary the input to the hash in a way not chosen by the attacker.<a class="self" href="#rfc.section.4.9.p.3">&para;</a></p></div></section><section id="n-precomputed-dictionary-attacks"><h3 id="rfc.section.4.10"><a href="#rfc.section.4.10">4.10</a>&nbsp;<a href="#n-precomputed-dictionary-attacks">Precomputed dictionary attacks</a></h3><div id="rfc.section.4.10.p.1"><p>With Digest authentication, if the attacker can execute a chosen plaintext attack, the attacker can precompute the response for many common words to a nonce of its choice, and store a dictionary of (response, password) pairs. Such precomputation can often be done in parallel on many machines. It can then use the chosen plaintext attack to acquire a response corresponding to that challenge, and just look up the password in the dictionary. Even if most passwords are not in the dictionary, some might be. Since the attacker gets to pick the challenge, the cost of computing the response for each password on the list can be amortized over finding many passwords. A dictionary with 100 million password/response pairs would take about 3.2 gigabytes of disk storage.<a class="self" href="#rfc.section.4.10.p.1">&para;</a></p></div><div id="rfc.section.4.10.p.2"><p>The countermeasure against this attack is to for clients to be configured to require the use of the optional "cnonce" directive.<a class="self" href="#rfc.section.4.10.p.2">&para;</a></p></div></section><section id="n-batch-brute-force-attacks"><h3 id="rfc.section.4.11"><a href="#rfc.section.4.11">4.11</a>&nbsp;<a href="#n-batch-brute-force-attacks">Batch brute force attacks</a></h3><div id="rfc.section.4.11.p.1"><p>With Digest authentication, a MITM can execute a chosen plaintext attack, and can gather responses from many users to the same nonce. It can then find all the passwords within any subset of password space that would generate one of the nonce/response pairs in a single pass over that space. It also reduces the time to find the first password by a factor equal to the number of nonce/response pairs gathered. This search of the password space can often be done in parallel on many machines, and even a single machine can search large subsets of the password space very quickly -- reports exist of searching all passwords with six or fewer letters in a few hours.<a class="self" href="#rfc.section.4.11.p.1">&para;</a></p></div><div id="rfc.section.4.11.p.2"><p>The countermeasure against this attack is to for clients to be configured to require the use of the optional "cnonce" directive.<a class="self" href="#rfc.section.4.11.p.2">&para;</a></p></div></section><section id="n-spoofing-by-counterfeit-servers"><h3 id="rfc.section.4.12"><a href="#rfc.section.4.12">4.12</a>&nbsp;<a href="#n-spoofing-by-counterfeit-servers">Spoofing by Counterfeit Servers</a></h3><div id="rfc.section.4.12.p.1"><p>Basic Authentication is vulnerable to spoofing by counterfeit servers. If a user can be led to believe that she is connecting to a host containing information protected by a password she knows, when in fact she is connecting to a hostile server, then the hostile server can request a password, store it away for later use, and feign an error. This type of attack is more difficult with Digest Authentication -- but the client must know to demand that Digest authentication be used, perhaps using some of the techniques described above to counter "man-in-the-middle" attacks. Again, the user can be helped in detecting this attack by a visual indication of the authentication mechanism in use with appropriate guidance in interpreting the implications of each scheme.<a class="self" href="#rfc.section.4.12.p.1">&para;</a></p></div></section><section id="n-storing-passwords"><h3 id="rfc.section.4.13"><a href="#rfc.section.4.13">4.13</a>&nbsp;<a href="#n-storing-passwords">Storing passwords</a></h3><div id="rfc.section.4.13.p.1"><p>Digest authentication requires that the authenticating agent (usually the server) store some data derived from the user's name and password in a "password file" associated with a given realm. Normally this might contain pairs consisting of username and H(A1), where H(A1) is the digested value of the username, realm, and password as described above.<a class="self" href="#rfc.section.4.13.p.1">&para;</a></p></div><div id="rfc.section.4.13.p.2"><p>The security implications of this are that if this password file is compromised, then an attacker gains immediate access to documents on the server using this realm. Unlike, say a standard UNIX password file, this information need not be decrypted in order to access documents in the server realm associated with this file. On the other hand, decryption, or more likely a brute force attack, would be necessary to obtain the user's password. This is the reason that the realm is part of the digested data stored in the password file. It means that if one Digest authentication password file is compromised, it does not automatically compromise others with the same username and password (though it does expose them to brute force attack).<a class="self" href="#rfc.section.4.13.p.2">&para;</a></p></div><div id="rfc.section.4.13.p.3"><p>There are two important security consequences of this. First the password file must be protected as if it contained unencrypted passwords, because for the purpose of accessing documents in its realm, it effectively does.<a class="self" href="#rfc.section.4.13.p.3">&para;</a></p></div><div id="rfc.section.4.13.p.4"><p>A second consequence of this is that the realm string should be unique among all realms which any single user is likely to use. In particular a realm string should include the name of the host doing the authentication. The inability of the client to authenticate the server is a weakness of Digest Authentication.<a class="self" href="#rfc.section.4.13.p.4">&para;</a></p></div></section><section id="n-summary"><h3 id="rfc.section.4.14"><a href="#rfc.section.4.14">4.14</a>&nbsp;<a href="#n-summary">Summary</a></h3><div id="rfc.section.4.14.p.1"><p>By modern cryptographic standards Digest Authentication is weak. But for a large range of purposes it is valuable as a replacement for Basic Authentication. It remedies some, but not all, weaknesses of Basic Authentication. Its strength may vary depending on the implementation. In particular the structure of the nonce (which is dependent on the server implementation) may affect the ease of mounting a replay attack. A range of server options is appropriate since, for example, some implementations may be willing to accept the server overhead of one-time nonces or digests to eliminate the possibility of replay. Others may satisfied with a nonce like the one recommended above restricted to a single IP address and a single ETag or with a limited lifetime.<a class="self" href="#rfc.section.4.14.p.1">&para;</a></p></div><div id="rfc.section.4.14.p.2"><p>The bottom line is that *any* compliant implementation will be relatively weak by cryptographic standards, but *any* compliant implementation will be far superior to Basic Authentication.<a class="self" href="#rfc.section.4.14.p.2">&para;</a></p></div></section></section><section id="n-sample-implementation"><h2 id="rfc.section.5"><a href="#rfc.section.5">5.</a>&nbsp;<a href="#n-sample-implementation">Sample implementation</a></h2><div id="rfc.section.5.p.1"><p>The following code implements the calculations of H(A1), H(A2), request-digest and response-digest, and a test program which computes the values used in the example of <a href="#specification.of.digest.headers.example" title="Example">Section&nbsp;3.5</a>. It uses the MD5 implementation from RFC 1321.<a class="self" href="#rfc.section.5.p.1">&para;</a></p></div><div id="rfc.figure.u.28"><p>File "digcalc.h":</p><pre class="text">#define HASHLEN 16
typedef char HASH[HASHLEN];
#define HASHHEXLEN 32
typedef char HASHHEX[HASHHEXLEN+1];
#define IN
#define OUT

/* calculate H(A1) as per HTTP Digest spec */
void DigestCalcHA1(
    IN char * pszAlg,
    IN char * pszUserName,
    IN char * pszRealm,
    IN char * pszPassword,
    IN char * pszNonce,
    IN char * pszCNonce,
    OUT HASHHEX SessionKey
    );

/* calculate request-digest/response-digest as per HTTP Digest spec */
void DigestCalcResponse(
    IN HASHHEX HA1,           /* H(A1) */
    IN char * pszNonce,       /* nonce from server */
    IN char * pszNonceCount,  /* 8 hex digits */
    IN char * pszCNonce,      /* client nonce */
    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
    IN char * pszMethod,      /* method from the request */
    IN char * pszDigestUri,   /* requested URL */
    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
    OUT HASHHEX Response      /* request-digest or response-digest */
    );
</pre></div><div id="rfc.figure.u.29"><p>File "digcalc.c":</p><pre class="text">#include &lt;global.h&gt;
#include &lt;md5.h&gt;
#include &lt;string.h&gt;
#include "digcalc.h"

void CvtHex(
    IN HASH Bin,
    OUT HASHHEX Hex
    )
{
    unsigned short i;
    unsigned char j;

    for (i = 0; i &lt; HASHLEN; i++) {
        j = (Bin[i] &gt;&gt; 4) &amp; 0xf;
        if (j &lt;= 9)
            Hex[i*2] = (j + '0');
         else
            Hex[i*2] = (j + 'a' - 10);
        j = Bin[i] &amp; 0xf;
        if (j &lt;= 9)
            Hex[i*2+1] = (j + '0');
         else
            Hex[i*2+1] = (j + 'a' - 10);
    };
    Hex[HASHHEXLEN] = '\0';
};

/* calculate H(A1) as per spec */
void DigestCalcHA1(
    IN char * pszAlg,
    IN char * pszUserName,
    IN char * pszRealm,
    IN char * pszPassword,
    IN char * pszNonce,
    IN char * pszCNonce,
    OUT HASHHEX SessionKey
    )
{
      MD5_CTX Md5Ctx;
      HASH HA1;

      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, pszUserName, strlen(pszUserName));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszRealm, strlen(pszRealm));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszPassword, strlen(pszPassword));
      MD5Final(HA1, &amp;Md5Ctx);
      if (stricmp(pszAlg, "md5-sess") == 0) {
            MD5Init(&amp;Md5Ctx);
            MD5Update(&amp;Md5Ctx, HA1, HASHLEN);
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, pszNonce, strlen(pszNonce));
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, pszCNonce, strlen(pszCNonce));
            MD5Final(HA1, &amp;Md5Ctx);
      };
      CvtHex(HA1, SessionKey);
};

/* calculate request-digest/response-digest as per HTTP Digest spec */
void DigestCalcResponse(
    IN HASHHEX HA1,           /* H(A1) */
    IN char * pszNonce,       /* nonce from server */
    IN char * pszNonceCount,  /* 8 hex digits */
    IN char * pszCNonce,      /* client nonce */
    IN char * pszQop,         /* qop-value: "", "auth", "auth-int" */
    IN char * pszMethod,      /* method from the request */
    IN char * pszDigestUri,   /* requested URL */
    IN HASHHEX HEntity,       /* H(entity body) if qop="auth-int" */
    OUT HASHHEX Response      /* request-digest or response-digest */
    )
{
      MD5_CTX Md5Ctx;
      HASH HA2;
      HASH RespHash;
       HASHHEX HA2Hex;

      // calculate H(A2)
      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, pszMethod, strlen(pszMethod));
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszDigestUri, strlen(pszDigestUri));
      if (stricmp(pszQop, "auth-int") == 0) {
            MD5Update(&amp;Md5Ctx, ":", 1);
            MD5Update(&amp;Md5Ctx, HEntity, HASHHEXLEN);
      };
      MD5Final(HA2, &amp;Md5Ctx);
       CvtHex(HA2, HA2Hex);

      // calculate response
      MD5Init(&amp;Md5Ctx);
      MD5Update(&amp;Md5Ctx, HA1, HASHHEXLEN);
      MD5Update(&amp;Md5Ctx, ":", 1);
      MD5Update(&amp;Md5Ctx, pszNonce, strlen(pszNonce));
      MD5Update(&amp;Md5Ctx, ":", 1);
      if (*pszQop) {
          MD5Update(&amp;Md5Ctx, pszNonceCount, strlen(pszNonceCount));
          MD5Update(&amp;Md5Ctx, ":", 1);
          MD5Update(&amp;Md5Ctx, pszCNonce, strlen(pszCNonce));
          MD5Update(&amp;Md5Ctx, ":", 1);
          MD5Update(&amp;Md5Ctx, pszQop, strlen(pszQop));
          MD5Update(&amp;Md5Ctx, ":", 1);
      };
      MD5Update(&amp;Md5Ctx, HA2Hex, HASHHEXLEN);
      MD5Final(RespHash, &amp;Md5Ctx);
      CvtHex(RespHash, Response);
};
</pre></div><div id="rfc.figure.u.30"><p>File "digtest.c":</p><pre class="text">#include &lt;stdio.h&gt;
#include "digcalc.h"

void main(int argc, char ** argv) {

      char * pszNonce = "dcd98b7102dd2f0e8b11d0f600bfb0c093";
      char * pszCNonce = "0a4f113b";
      char * pszUser = "Mufasa";
      char * pszRealm = "testrealm@host.com";
      char * pszPass = "Circle Of Life";
      char * pszAlg = "md5";
      char szNonceCount[9] = "00000001";
      char * pszMethod = "GET";
      char * pszQop = "auth";
      char * pszURI = "/dir/index.html";
      HASHHEX HA1;
      HASHHEX HA2 = "";
      HASHHEX Response;

      DigestCalcHA1(pszAlg, pszUser, pszRealm, pszPass, pszNonce,
pszCNonce, HA1);
      DigestCalcResponse(HA1, pszNonce, szNonceCount, pszCNonce, pszQop,
       pszMethod, pszURI, HA2, Response);
      printf("Response = %s\n", Response);
};
</pre></div></section><section id="n-acknowledgments"><h2 id="rfc.section.6"><a href="#rfc.section.6">6.</a>&nbsp;<a href="#n-acknowledgments">Acknowledgments</a></h2><div id="rfc.section.6.p.1"><p>Eric W. Sink, of AbiSource, Inc., was one of the original authors before the specification underwent substantial revision.<a class="self" href="#rfc.section.6.p.1">&para;</a></p></div><div id="rfc.section.6.p.2"><p>In addition to the authors, valuable discussion instrumental in creating this document has come from Peter J. Churchyard, Ned Freed, and David M. Kristol.<a class="self" href="#rfc.section.6.p.2">&para;</a></p></div><div id="rfc.section.6.p.3"><p>Jim Gettys and Larry Masinter edited this document for update.<a class="self" href="#rfc.section.6.p.3">&para;</a></p></div></section><section id="rfc.references"><h2 id="rfc.section.7"><a href="#rfc.section.7">7.</a> References</h2><dl class="reference"><dt id="RFC1945">[1]</dt><dd><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, and <a href="mailto:frystyk@w3.org">H. Nielsen</a>, &#8220;<a href="https://tools.ietf.org/html/rfc1945">Hypertext Transfer Protocol -- HTTP/1.0</a>&#8221;, RFC&nbsp;1945, May&nbsp;1996.</dd><dt id="RFC2616">[2]</dt><dd><a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, <a href="mailto:jg@w3.org">Gettys, J.</a>, <a href="mailto:mogul@wrl.dec.com">Mogul, J.</a>, <a href="mailto:frystyk@w3.org">Nielsen, H.</a>, <a href="mailto:masinter@parc.xerox.com">Masinter, L.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, and <a href="mailto:timbl@w3.org">T. Berners-Lee</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2616">Hypertext Transfer Protocol -- HTTP/1.1</a>&#8221;, RFC&nbsp;2616, June&nbsp;1999.</dd><dt id="RFC1321">[3]</dt><dd><a href="mailto:rivest@theory.lcs.mit.edu">Rivest, R.</a>, &#8220;<a href="https://tools.ietf.org/html/rfc1321">The MD5 Message-Digest Algorithm</a>&#8221;, RFC&nbsp;1321, April&nbsp;1992.</dd><dt id="RFC2045">[4]</dt><dd><a href="mailto:ned@innosoft.com">Freed, N.</a> and <a href="mailto:nsb@nsb.fv.com">N. Borenstein</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2045">Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies</a>&#8221;, RFC&nbsp;2045, November&nbsp;1996.</dd><dt id="RFC2246">[5]</dt><dd><a href="mailto:tdierks@certicom.com">Dierks, T.</a> and <a href="mailto:callen@certicom.com">C. Allen</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2246">The TLS Protocol Version 1.0</a>&#8221;, RFC&nbsp;2246, January&nbsp;1999.</dd><dt id="RFC2069">[6]</dt><dd><a href="mailto:john@math.nwu.edu">Franks, J.</a>, <a href="mailto:hallam@w3.org">Hallam-Baker, P.</a>, <a href="mailto:jeff@spyglass.com">Hostetler, J.</a>, <a href="mailto:paulle@microsoft.com">Leach, P.</a>, <a href="mailto:luotonen@netscape.com">Luotonen, A.</a>, <a href="mailto:eric@spyglass.com">Sink, E.</a>, and <a href="mailto:stewart@OpenMarket.com">L. Stewart</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2069">An Extension to HTTP : Digest Access Authentication</a>&#8221;, RFC&nbsp;2069, January&nbsp;1997.</dd><dt id="RFC2396">[7]</dt><dd><a href="mailto:timbl@w3.org">Berners-Lee, T.</a>, <a href="mailto:fielding@ics.uci.edu">Fielding, R.</a>, and <a href="mailto:masinter@parc.xerox.com">L. Masinter</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2396">Uniform Resource Identifiers (URI): Generic Syntax</a>&#8221;, RFC&nbsp;2396, August&nbsp;1998.</dd><dt id="ref8">[8]</dt><dd>Kaliski, B. and M. Robshaw, &#8220;<a href="http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm">Message Authentication with MD5</a>&#8221;, 1995, &lt;<a href="http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm">http://www.rsa.com/rsalabs/pubs/cryptobytes/spring95/md5.htm</a>&gt;.<br>CryptoBytes, Spring 1995</dd><dt id="RFC2195">[9]</dt><dd><a href="mailto:klensin@mci.net">Klensin, J.</a>, <a href="mailto:randy@mci.net">Catoe, R.</a>, and <a href="mailto:paul@mci.net">P. Krumviede</a>, &#8220;<a href="https://tools.ietf.org/html/rfc2195">IMAP/POP AUTHorize Extension for Simple Challenge/Response</a>&#8221;, RFC&nbsp;2195, September&nbsp;1997.</dd><dt id="ref10">[10]</dt><dd>Morgan, B., Alvestrand, H., Hodges, J., and M. Wahl, &#8220;Authentication Methods for LDAP&#8221;.<br>Work in progress.</dd></dl></section><section id="rfc.index"><h2><a href="#rfc.index">Index</a></h2><p class="noprint"><a href="#rfc.index.A">A</a> <a href="#rfc.index.B">B</a> <a href="#rfc.index.C">C</a> <a href="#rfc.index.D">D</a> <a href="#rfc.index.H">H</a> <a href="#rfc.index.L">L</a> <a href="#rfc.index.M">M</a> <a href="#rfc.index.N">N</a> <a href="#rfc.index.O">O</a> <a href="#rfc.index.P">P</a> <a href="#rfc.index.Q">Q</a> <a href="#rfc.index.R">R</a> <a href="#rfc.index.S">S</a> <a href="#rfc.index.U">U</a> <a href="#rfc.index.W">W</a> </p><div class="print2col"><ul class="ind"><li><a id="rfc.index.A" href="#rfc.index.A"><b>A</b></a><ul><li><span class="tt">algorithm</span>&nbsp;&nbsp;<a href="#rfc.iref.a.3"><b>3.2.1</b></a></li><li><span class="tt">auth-info</span>&nbsp;&nbsp;<a href="#rfc.iref.a.5"><b>3.2.3</b></a></li><li><span class="tt">auth-param</span>&nbsp;&nbsp;<a href="#rfc.iref.a.2"><b>1.2</b></a></li><li><span class="tt">auth-scheme</span>&nbsp;&nbsp;<a href="#rfc.iref.a.1"><b>1.2</b></a></li><li><span class="tt">Authentication-Info</span>&nbsp;&nbsp;<a href="#rfc.iref.a.4"><b>3.2.3</b></a></li><li>Authentication-Info header&nbsp;&nbsp;<a href="#rfc.section.3.2.3"><b>3.2.3</b></a></li><li>Authorization header&nbsp;&nbsp;<a href="#rfc.section.3.2.2"><b>3.2.2</b></a></li></ul></li><li><a id="rfc.index.B" href="#rfc.index.B"><b>B</b></a><ul><li><span class="tt">base64-user-pass</span>&nbsp;&nbsp;<a href="#rfc.iref.b.2"><b>2</b></a></li><li><span class="tt">basic-credentials</span>&nbsp;&nbsp;<a href="#rfc.iref.b.1"><b>2</b></a></li></ul></li><li><a id="rfc.index.C" href="#rfc.index.C"><b>C</b></a><ul><li><span class="tt">challenge</span>&nbsp;&nbsp;<a href="#rfc.iref.c.1"><b>1.2</b></a>, <a href="#rfc.iref.c.3">2</a>, <a href="#rfc.iref.c.5">3.2.1</a></li><li><span class="tt">cnonce</span>&nbsp;&nbsp;<a href="#rfc.iref.c.7"><b>3.2.2</b></a></li><li><span class="tt">cnonce-value</span>&nbsp;&nbsp;<a href="#rfc.iref.c.8"><b>3.2.2</b></a></li><li><span class="tt">credentials</span>&nbsp;&nbsp;<a href="#rfc.iref.c.2"><b>1.2</b></a>, <a href="#rfc.iref.c.4">2</a>, <a href="#rfc.iref.c.6">3.2.2</a></li></ul></li><li><a id="rfc.index.D" href="#rfc.index.D"><b>D</b></a><ul><li><span class="tt">digest-challenge</span>&nbsp;&nbsp;<a href="#rfc.iref.d.1"><b>3.2.1</b></a></li><li><span class="tt">digest-response</span>&nbsp;&nbsp;<a href="#rfc.iref.d.3"><b>3.2.2</b></a></li><li><span class="tt">digest-uri</span>&nbsp;&nbsp;<a href="#rfc.iref.d.4"><b>3.2.2</b></a></li><li><span class="tt">digest-uri-value</span>&nbsp;&nbsp;<a href="#rfc.iref.d.5"><b>3.2.2</b></a></li><li><span class="tt">domain</span>&nbsp;&nbsp;<a href="#rfc.iref.d.2"><b>3.2.1</b></a></li></ul></li><li><a id="rfc.index.H" href="#rfc.index.H"><b>H</b></a><ul><li>Headers&nbsp;&nbsp;<ul><li>Authentication-Info&nbsp;&nbsp;<a href="#rfc.section.3.2.3"><b>3.2.3</b></a></li><li>Authorization&nbsp;&nbsp;<a href="#rfc.section.3.2.2"><b>3.2.2</b></a></li><li>WWW-Authenticate&nbsp;&nbsp;<a href="#rfc.section.3.2.1"><b>3.2.1</b></a></li></ul></li></ul></li><li><a id="rfc.index.L" href="#rfc.index.L"><b>L</b></a><ul><li><span class="tt">LHEX</span>&nbsp;&nbsp;<a href="#rfc.iref.l.1"><b>3.2.2</b></a></li></ul></li><li><a id="rfc.index.M" href="#rfc.index.M"><b>M</b></a><ul><li><span class="tt">message-qop</span>&nbsp;&nbsp;<a href="#rfc.iref.m.1"><b>3.2.2</b></a></li></ul></li><li><a id="rfc.index.N" href="#rfc.index.N"><b>N</b></a><ul><li><span class="tt">nc-value</span>&nbsp;&nbsp;<a href="#rfc.iref.n.4"><b>3.2.2</b></a></li><li><span class="tt">nextnonce</span>&nbsp;&nbsp;<a href="#rfc.iref.n.5"><b>3.2.3</b></a></li><li><span class="tt">nonce</span>&nbsp;&nbsp;<a href="#rfc.iref.n.1"><b>3.2.1</b></a></li><li><span class="tt">nonce-count</span>&nbsp;&nbsp;<a href="#rfc.iref.n.3"><b>3.2.2</b></a></li><li><span class="tt">nonce-value</span>&nbsp;&nbsp;<a href="#rfc.iref.n.2"><b>3.2.1</b></a></li></ul></li><li><a id="rfc.index.O" href="#rfc.index.O"><b>O</b></a><ul><li><span class="tt">opaque</span>&nbsp;&nbsp;<a href="#rfc.iref.o.1"><b>3.2.1</b></a></li></ul></li><li><a id="rfc.index.P" href="#rfc.index.P"><b>P</b></a><ul><li><span class="tt">password</span>&nbsp;&nbsp;<a href="#rfc.iref.p.1"><b>2</b></a></li></ul></li><li><a id="rfc.index.Q" href="#rfc.index.Q"><b>Q</b></a><ul><li><span class="tt">qop-options</span>&nbsp;&nbsp;<a href="#rfc.iref.q.1"><b>3.2.1</b></a></li><li><span class="tt">qop-value</span>&nbsp;&nbsp;<a href="#rfc.iref.q.2"><b>3.2.1</b></a></li></ul></li><li><a id="rfc.index.R" href="#rfc.index.R"><b>R</b></a><ul><li><span class="tt">realm</span>&nbsp;&nbsp;<a href="#rfc.iref.r.1"><b>1.2</b></a></li><li><span class="tt">realm-value</span>&nbsp;&nbsp;<a href="#rfc.iref.r.2"><b>1.2</b></a></li><li><em>10</em>&nbsp;&nbsp;<a href="#rfc.xref.ref10.1">4.2</a>, <a href="#ref10"><b>7</b></a></li><li><em>8</em>&nbsp;&nbsp;<a href="#rfc.xref.ref8.1">4.9</a>, <a href="#ref8"><b>7</b></a></li><li><span class="tt">request-digest</span>&nbsp;&nbsp;<a href="#rfc.iref.r.4"><b>3.2.2</b></a></li><li><span class="tt">response</span>&nbsp;&nbsp;<a href="#rfc.iref.r.3"><b>3.2.2</b></a></li><li><span class="tt">response-auth</span>&nbsp;&nbsp;<a href="#rfc.iref.r.5"><b>3.2.3</b></a></li><li><span class="tt">response-digest</span>&nbsp;&nbsp;<a href="#rfc.iref.r.6"><b>3.2.3</b></a></li><li><em>3</em>&nbsp;&nbsp;<a href="#RFC1321"><b>7</b></a></li><li><em>1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC1945.1">3.1.1</a>, <a href="#RFC1945"><b>7</b></a></li><li><em>4</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2045.1">2</a>, <a href="#RFC2045"><b>7</b></a></li><li><em>6</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2069.1">&sect;</a>, <a href="#rfc.xref.RFC2069.2">3.2.1</a>, <a href="#rfc.xref.RFC2069.3">3.2.2</a>, <a href="#RFC2069"><b>7</b></a></li><li><em>9</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2195.1">4.2</a>, <a href="#RFC2195"><b>7</b></a></li><li><em>5</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2246.1">&sect;</a>, <a href="#RFC2246"><b>7</b></a></li><li><em>7</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2396.1">2</a>, <a href="#rfc.xref.RFC2396.2">3.2.1</a>, <a href="#RFC2396"><b>7</b></a></li><li><em>2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.1">1.1</a>, <a href="#rfc.xref.RFC2616.2">1.1</a>, <a href="#rfc.xref.RFC2616.3">1.2</a>, <a href="#rfc.xref.RFC2616.4">1.2</a>, <a href="#rfc.xref.RFC2616.5">1.2</a>, <a href="#rfc.xref.RFC2616.6">1.2</a>, <a href="#rfc.xref.RFC2616.7">1.2</a>, <a href="#rfc.xref.RFC2616.8">1.2</a>, <a href="#rfc.xref.RFC2616.9">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.10">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.11">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.12">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.13">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.14">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.15">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.16">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.17">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.18">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.19">3.6</a>, <a href="#rfc.xref.RFC2616.20">3.6</a>, <a href="#rfc.xref.RFC2616.21">3.6</a>, <a href="#RFC2616"><b>7</b></a><ul><li><em>Section 10.33</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.19">3.6</a></li><li><em>Section 10.34</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.20">3.6</a></li></ul><ul><li><em>Section 2.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.2">1.1</a></li><li><em>Section 5.1.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.9">3.2.2.5</a></li><li><em>Section 5.1.2</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.3">1.2</a>, <a href="#rfc.xref.RFC2616.11">3.2.2.5</a>, <a href="#rfc.xref.RFC2616.13">3.2.2.5</a></li><li><em>Section 13.5.1</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.7">1.2</a></li><li><em>Section 13.7</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.15">3.2.2.5</a></li><li><em>Section 14.8</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.5">1.2</a></li><li><em>Section 14.9</em>&nbsp;&nbsp;<a href="#rfc.xref.RFC2616.17">3.2.2.5</a></li></ul></li></ul></li><li><a id="rfc.index.S" href="#rfc.index.S"><b>S</b></a><ul><li><span class="tt">stale</span>&nbsp;&nbsp;<a href="#rfc.iref.s.1"><b>3.2.1</b></a></li></ul></li><li><a id="rfc.index.U" href="#rfc.index.U"><b>U</b></a><ul><li><span class="tt">URI</span>&nbsp;&nbsp;<a href="#rfc.iref.u.3"><b>3.2.1</b></a></li><li><span class="tt">user-pass</span>&nbsp;&nbsp;<a href="#rfc.iref.u.1"><b>2</b></a></li><li><span class="tt">userid</span>&nbsp;&nbsp;<a href="#rfc.iref.u.2"><b>2</b></a></li><li><span class="tt">username</span>&nbsp;&nbsp;<a href="#rfc.iref.u.4"><b>3.2.2</b></a></li><li><span class="tt">username-value</span>&nbsp;&nbsp;<a href="#rfc.iref.u.5"><b>3.2.2</b></a></li></ul></li><li><a id="rfc.index.W" href="#rfc.index.W"><b>W</b></a><ul><li>WWW-Authenticate header&nbsp;&nbsp;<a href="#rfc.section.3.2.1"><b>3.2.1</b></a></li></ul></li></ul></div></section><section id="rfc.authors" class="avoidbreakinside"><h2><a href="#rfc.authors">Authors' Addresses</a></h2><address><b>John Franks</b><br>Northwestern University, Department of Mathematics<br>Northwestern University<br>Evanston, IL&nbsp;60208-2730<br>USA<br>EMail: <a href="mailto:john@math.nwu.edu">john@math.nwu.edu</a></address><address><b>Phillip M. Hallam-Baker</b><br>Verisign Inc.<br>301 Edgewater Place<br>Suite 210<br>Wakefield, MA&nbsp;01880<br>USA<br>EMail: <a href="mailto:pbaker@verisign.com">pbaker@verisign.com</a></address><address><b>Jeffery L. Hostetler</b><br>AbiSource, Inc.<br>6 Dunlap Court<br>Savoy, IL&nbsp;61874<br>USA<br>EMail: <a href="mailto:jeff@AbiSource.com">jeff@AbiSource.com</a></address><address><b>Scott D. Lawrence</b><br>Agranat Systems, Inc.<br>5 Clocktower Place<br>Suite 400<br>Maynard, MA&nbsp;01754<br>USA<br>EMail: <a href="mailto:lawrence@agranat.com">lawrence@agranat.com</a></address><address><b>Paul J. Leach</b><br>Microsoft Corporation<br>1 Microsoft Way<br>Redmond, WA&nbsp;98052<br>USA<br>EMail: <a href="mailto:paulle@microsoft.com">paulle@microsoft.com</a></address><address><b>Ari Luotonen</b><br>Netscape Communications Corporation<br>501 East Middlefield Road<br>Mountain View, CA&nbsp;94043<br>USA</address><address><b>Lawrence C. Stewart</b><br>Open Market, Inc.<br>215 First Street<br>Cambridge, MA&nbsp;02142<br>USA<br>EMail: <a href="mailto:stewart@OpenMarket.com">stewart@OpenMarket.com</a></address></section><section id="rfc.copyright"><h2><a href="#rfc.copyright">Full Copyright Statement</a></h2><p>Copyright &copy; The Internet Society (1999). All Rights Reserved.</p><p>This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.</p><p>The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.</p><p>This document and the information contained herein is provided on an &#8220;AS IS&#8221; basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.</p></section><section id="rfc.ipr"><h2><a href="#rfc.ipr">Intellectual Property</a></h2><p>The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.</p><p>The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.</p></section><section id="n-acknowledgment"><h2><a href="#n-acknowledgment">Acknowledgment</a></h2><p>Funding for the RFC Editor function is currently provided by the Internet Society.</p></section></body></html>
